#!/bin/env bash

# shellcheck disable=SC2317   # Notice about unreachable commands

# Copyright (C) 2023, Kolade Ayomide Olanrewaju (tether)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

#--------------------------------------------------------------
################### BEGIN IMPORTANT NOTICE ####################
#--------------------------------------------------------------
# Functions and variables in this section are only used within this script and
# cannot be accessed externally, as such they follow a specific
# naming convention to highlight the difference *_* e.g print_success
# DO NOT USE THIS NAMING SCHEME FOR ANY EXTERNAL FUNCTIONS

#--------------------------------------------------------------
# Check if bash version is >= 5
#--------------------------------------------------------------
[[ ${BASH_VERSINFO[0]} -lt 5 ]] && {
	printf "\033[1;97m[\033[1;31m-\033[1;97m] Bash 5.0 or later is required to run this script \n\033[00m" >&2
	exit 1
}

#--------------------------------------------------------------
# Set the name of this script
#--------------------------------------------------------------
SCRIPT_NAME="${0##*/}"

#--------------------------------------------------------------
# Set the version of this script
#--------------------------------------------------------------
SCRIPT_VERSION="2024.02.18.2258"

#--------------------------------------------------------------
# Set global variables if running on Android
#--------------------------------------------------------------
[[ -d /system/app/ && -f /system/build.prop ]] && {
	# Don't use any fallback if not in a magisk module
	unset MODULE_DIRECTORY

	# Don't use any fallback if no external storage
	unset EXTERNAL_STORAGE

	# Set module directory if installed in a magisk module
	for module_precursor in /data/adb/modules/*; do
		[[ -f $module_precursor/system/bin/tether ]] && {
			MODULE_DIRECTORY="$module_precursor"
			break
		}
	done

	# Set external storage to USB-OTG or SD card if available
	for available_storage in /storage/*-*; do
		[[ -d $available_storage ]] && {
			export EXTERNAL_STORAGE="$available_storage"
			break
		}
	done

	# Set Termux directory
	TERMUX_DIRECTORY="/data/data/com.termux/files"

	# Set internal storage
	PHONE_STORAGE="/mnt/sdcard"

	# Set Android version for non-root user
	[[ $USER != "root" || $EUID -ne 0 ]] && [[ -n $EUID ]] && {
		[[ -f /product/etc/build.prop ]] && {
			ANDROID_VERSION="$(< /product/etc/build.prop)"
		}
		[[ -f /product/build.prop ]] && {
			ANDROID_VERSION="$(< /product/build.prop)"
		}
		ANDROID_VERSION="${ANDROID_VERSION/*ro.product.build.version.release=}"
		ANDROID_VERSION="${ANDROID_VERSION/ro.product.build.version.release_or_codename=*}"
		ANDROID_VERSION="${ANDROID_VERSION/[[:space:]]}"
	}

	# Set Android version for root user
	[[ $USER == "root" || $EUID -eq 0 ]] && {
		ANDROID_VERSION="$(< /system/build.prop)"
		ANDROID_VERSION="${ANDROID_VERSION/*ro.system.build.version.release=}"
		ANDROID_VERSION="${ANDROID_VERSION/ro.system.build.version.release_or_codename=*}"
		ANDROID_VERSION="${ANDROID_VERSION/[[:space:]]}"
	}
}

#--------------------------------------------------------------
# Get the available number of cpu threads
#--------------------------------------------------------------
CPU_CORE_COUNT="$(< /sys/devices/system/cpu/online)"
CPU_CORE_COUNT="${CPU_CORE_COUNT//*\-}"
CPU_CORE_COUNT="${CPU_CORE_COUNT//[[:space:]]}"
CPU_CORE_COUNT="$((CPU_CORE_COUNT + 1))"

#--------------------------------------------------------------
# Print out error message to stderr
#--------------------------------------------------------------
print_error() {
	printf '\033[1;97m[\033[1;31m-\033[1;97m] %s \n\033[00m' "$@" >&2
}

#--------------------------------------------------------------
# Print out success message
#--------------------------------------------------------------
print_success() {
	printf '\033[1;97m[\033[1;32m+\033[1;97m] %s \n\033[00m' "$@"
}

#--------------------------------------------------------------
# Print out warning/notice
#--------------------------------------------------------------
print_warning() {
	printf '\033[1;97m[\033[1;35m*\033[1;97m] %s \n\033[00m' "$@"
}

#--------------------------------------------------------------
# Print out non bold text aligned with print_error
#--------------------------------------------------------------
print_aligned() {
	printf '    %s\n' "$@"
}

#--------------------------------------------------------------
# Print out status message on exit
#--------------------------------------------------------------
run_on_exit() {
	printf '\n\n'
	print_error "Aborted"
	unset file_password
	unset file_password2
	exit 1
}

#--------------------------------------------------------------
# Remove files and print out status message on exit
#--------------------------------------------------------------
remove_file_on_exit() {
	printf '\n\n'
	print_error "Aborted"
	rm -r "$@" 2>/dev/null
	unset file_password
	unset file_password2
	exit 1
}

#--------------------------------------------------------------
# Print out notice/guide after error
#--------------------------------------------------------------
print_notification() {
	print_aligned "Try '$SCRIPT_NAME --help' for more information." >&2
	exit 1
}

#--------------------------------------------------------------
# Print out error message if there no input argument
#--------------------------------------------------------------
print_no_argument() {
	[[ $# -eq 0 ]] && {
		print_error "Missing operand"
		print_aligned "Try '$SCRIPT_NAME --help' for more information." >&2
		exit 1
	}
}

#--------------------------------------------------------------
# Print unsupported OS error
#--------------------------------------------------------------
print_os_error() {
	print_error "Unsupported OS detected"
	exit 1
}

#--------------------------------------------------------------
# Print missing dependencies error
#--------------------------------------------------------------
print_missing_dependencies() {
	print_error "'$*' is not installed"
	exit 1
}

#--------------------------------------------------------------
# Print insufficient write/read permissions error
#--------------------------------------------------------------
print_write_error() {
	print_error "Cannot create directory '$1': Permission denied"
	exit 1
}

print_file_write_error() {
	print_error "Cannot create file '$1': Permission denied"
	exit 1
}

print_file_read_error() {
	print_error "Cannot read '$1' file: Permission denied"
	exit 1
}

#--------------------------------------------------------------
# Print failure to change current directory
#--------------------------------------------------------------
print_dir_change_error() {
	print_error "Failed to change current directory to '$1'"
	exit 1
}

#--------------------------------------------------------------
# Print syntax error
#--------------------------------------------------------------
print_syntax_error() {
	print_error "Syntax error"
	print_notification
}

#--------------------------------------------------------------
# Print user permissions error
#--------------------------------------------------------------
print_not_root_user() {
	[[ $EUID -gt 0 ]] && {
		print_error "Running as non-root user is not supported"
		exit 1
	}
}

print_not_normal_user() {
	[[ $EUID -eq 0 ]] && {
		print_error "Running as root user is not supported"
		exit 1
	}
}

#--------------------------------------------------------------
# Print version info
#--------------------------------------------------------------
print_version() {
	printf '%s (tether) %s\n
Copyright (C) 2023, Kolade Ayomide Olanrewaju.
License GPLv3+: GNU GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Kolade Ayomide Olanrewaju.\n' "$SCRIPT_NAME" "${SCRIPT_VERSION}"
exit 0
}

#--------------------------------------------------------------
# Handle password creation
#--------------------------------------------------------------
create_password() {
	read -rsp "Input Password: " file_password
	printf '\n'

	read -rsp "Verify Password: " file_password2
	printf '\n\n'

	[[ $file_password != "$file_password2" ]] && {
		print_error "Passwords do not match"
		unset file_password
		unset file_password2
		exit 1
	}

	[[ -z $file_password ]] && {
		print_error "Password string cannot be empty"
		unset file_password
		unset file_password2
		exit 1
	}
}

#--------------------------------------------------------------
# Handle input options/arguments
#--------------------------------------------------------------
input_option_type_one() {
	for primary_options in "${@:1}"; do
		case "$primary_options" in
			-h | --help)
				print_help
			;;
			-V | --version)
				print_version
			;;
			-*)
				for secondary_options in "${@:2}"; do
					case "$secondary_options" in
						-h | --help)
							print_help
						;;
					esac
				done

				[[ -z ${primary_options#*\-} || -z ${primary_options/\-\-*} ]] && {
					print_error "Unrecognized option '${primary_options}'"
					print_notification
				}

				print_error "Invalid option -- '${primary_options#*\-}'"
				print_notification
			;;
		esac
	done
}

input_option_type_two() {
	for primary_options in "${@:1}"; do
		case "$primary_options" in
			-h | --help)
				print_help
			;;
			-V | --version)
				print_version
			;;
			-*)
				[[ -z ${primary_options#*\-} || -z ${primary_options/\-\-*} ]] && {
					print_error "Unrecognized option '${primary_options}'"
					print_notification
				}

				print_error "Invalid option -- '${primary_options#*\-}'"
				print_notification
			;;
			*)
				print_error "Unrecognized option '${primary_options}'"
				print_notification
			;;
		esac
	done
}

#--------------------------------------------------------------
# Print program banner
#--------------------------------------------------------------
print_banner() {
	printf " 
████████╗███████╗████████╗██╗   ██╗███████╗██████═╗
╚══██╔══╝██╔════╝╚══██╔══╝██║   ██║██╔════╝██╔═══██ 
   ██║   ███████╗   ██║   ████████║███████╗███████═╗
   ██║   ██╔════╝   ██║   ██╔═══██║██╔════╝██╔═══██║
   ██║   ███████╗   ██║   ██║   ██║███████╗██║   ██║
   ╚═╝   ╚══════╝   ╚═╝   ╚═╝   ╚═╝╚══════╝╚═╝   ╚═╝
\n"
}

#--------------------------------------------------------------
# Print colored usage/progress bar
#--------------------------------------------------------------
print_usage_bar() {
	# Set colors
	color_red="\033[1;31m"
	color_green="\033[1;32m"
	color_yellow="\033[1;33m"
	color_white="\033[1;97m"

	# Reduce $usage_visualizer size to reduce runtime
	usage_counter="$(( usage_visualizer / 5 ))"

	# Handles all $usage_visualizer values > 0
	out_block="${color_green}"

	for ((blk_counter=0; blk_counter < usage_counter; blk_counter++)); do
		out_block+="■"
		# Show ${color_yellow} blocks after 7 ${color_green} blocks
		[[ $blk_counter -eq 6 ]] && {
			out_block+="${color_yellow}"
		}
		# Show ${color_red} blocks after 7 ${color_yellow} blocks
		[[ $blk_counter -eq 13 ]] && {
			out_block+="${color_red}"
		}
	done

	# Handles $usage_visualizer values <= 0 || $usage_visualizer values < 100
	out_empty="${color_white}"
	for ((; blk_counter < 20; blk_counter++)); do
		out_empty+="-"
	done

	# Output colored progress bar
	printf '%s[ %s%s ]\n' "${color_white}" "${out_block}" "${out_empty}"
}

#--------------------------------------------------------------
# Change linux timezone
#--------------------------------------------------------------
change_timezone() {
	# Set Timezone
	zone_count=1

	# Show available timezone files
	for zone_files in /usr/share/zoneinfo/*; do
		[[ -d $zone_files && ${zone_files##*/} != posix && ${zone_files##*/} != right ]] && {
			printf '%s. %s  ' "${zone_count}" "${zone_files##*/}"
			time_zone[zone_count]="$zone_files"
			zone_count=$((zone_count + 1))
		}
	done

	printf '\n\n'
	# Read user input
	read -rep "Select Timezone: " tz_option
	printf '\n'

	# Handles invalid user input
	[[ -z $tz_option ]] && {
		print_error "Timezone string cannot be empty" &&
		exit 1
	}

	case "$tz_option" in
		-*)
			printf '\n'
			[[ -z ${tz_option#*\-} || -z ${tz_option/\-\-*} ]] && {
				print_error "Unrecognized option '${tz_option}'" &&
				exit 1
			}

			print_error "Invalid option -- '${tz_option#*\-}'" &&
			exit 1
		;;
		*)
			# List subzones in user selection
			[[ $tz_option -ge 1 && $tz_option -le $zone_count ]] && {
				# List subzones files
				zone_count=1
				for sub_zone_files in "${time_zone[$tz_option]}"/*; do
					printf '%s. %s  ' "${zone_count}" "${sub_zone_files##*/}"
					sub_zone[zone_count]="$sub_zone_files"
					zone_count=$((zone_count + 1))
				done
				printf '\n\n'
				# Read user input
				read -rep "Select Region: " tz_locale
				printf '\n'

				# If location in user selection is defined
				[[ -f ${sub_zone[$tz_locale]} && $tz_locale -ge 1 && $tz_locale -le $zone_count ]] && {
					ln -sf "/usr/share/zoneinfo/${time_zone[$tz_option]##*/}/${sub_zone[$tz_locale]##*/}" "/etc/localtime" 2>/dev/null &&
					return 0
				}

				# If location in user selection has sublocation
				[[ -d ${sub_zone[$tz_locale]} && $tz_locale -ge 1 && $tz_locale -le $zone_count ]] && {
					# List all sublocale files
					zone_count=1
					for sub_region_files in "${sub_zone[$tz_locale]}"/*; do
						printf '%s. %s  ' "${zone_count}" "${sub_region_files##*/}"
						sub_region[zone_count]="$sub_region_files"
						zone_count=$((zone_count + 1))
					done
					printf '\n\n'
					# Read user input
					read -rep "Select Location: " sub_locale
					printf '\n'

					# If location in user selection is defined
					[[ -f ${sub_region[$sub_locale]} && $sub_locale -ge 1 && $sub_locale -le $zone_count ]] && {
						ln -sf "/usr/share/zoneinfo/${time_zone[$tz_option]##*/}/${sub_zone[$tz_locale]##*/}/${sub_region[$sub_locale]##*/}" "/etc/localtime" 2>/dev/null &&
						return 0
					}

					# Handles invalid user input
					[[ -z $sub_locale ]] && {
						print_error "Location string cannot be empty" &&
						exit 1
					}

					[[ $sub_locale -lt 1 || $sub_locale -gt $zone_count ]] && {
						print_error "Unrecognized option '${sub_locale}'" &&
						exit 1
					}
				}

				# Handles invalid user input
				[[ -z $tz_locale ]] && {
					print_error "Region string cannot be empty" &&
					exit 1
				}

				[[ $tz_locale -lt 1 || $tz_locale -gt $zone_count ]] && {
					print_error "Unrecognized option '${tz_locale}'" &&
					exit 1
				}
			}

			[[ $tz_option -lt 1 || $tz_option -gt $zone_count ]] && {
				print_error "Unrecognized option '${tz_option}'" &&
				exit 1
			}
		;;
	esac
}

#--------------------------------------------------------------
#################### END IMPORTANT NOTICE #####################
#--------------------------------------------------------------

#--------------------------------------------------------------
# Platform: Device Agnostic
# Dependencies: bc, bash
#--------------------------------------------------------------
benchmark() {
	print_help() {
echo -e "\033[1;97mNAME\033[00m
	$SCRIPT_NAME - single core performance benchmark tool.

\033[1;97mSYNOPSIS\033[00m
	$SCRIPT_NAME [OPTION] [NUMBER]

\033[1;97mDESCRIPTION\033[00m
	Perform quick system performance comparison using pure bash.
	It has no external dependencies for '--iterations' <= 62.

	\033[1;97m-h,  --help\033[00m
		display this help message and exit.

	\033[1;97m-it, --iteration\033[00m [NUMBER]
		specifies the number of iterations to perform, this
		option only accepts positive integers for [NUMBER].

	\033[1;97m-V,  --version\033[00m
		output version information and exit.

\033[1;97mAUTHOR\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.
	Written by Kolade Ayomide Olanrewaju.

\033[1;97mREPORTING BUGS\033[00m
	Create a new issue at <https://github.com/teth3r/tether/>.

\033[1;97mCOPYRIGHT\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.

tether $SCRIPT_VERSION"
exit 0
	}

	prime_test_benchmark() {
		found_mersenne_primes=0

		for ((prime_numbers=1; prime_numbers < user_iteration; prime_numbers++)); do
			# Use bash to find mersenne numbers
			# Use mersenne formula 2^n - 1
			[[ $user_iteration -le 62 ]] && {
				mersenne_numbers="$(( (2 ** prime_numbers) - 1 ))"
			}

			# Use bc to find mersenne numbers
			# Use mersenne formula 2^n - 1
			[[ $user_iteration -ge 63 ]] && {
				mersenne_numbers=$( printf '%d ^ %d - %d\n' "2" "$prime_numbers" "1" | bc )
				mersenne_numbers=${mersenne_numbers//\\}
				mersenne_numbers=${mersenne_numbers//[[:space:]]}
			}

			# Test found mersenne numbers for primality
			for ((primality_checker=0, calculated_range=1; calculated_range < mersenne_numbers / 2; calculated_range++)); do
				primality_test=$(( mersenne_numbers % calculated_range ))

				[[ $primality_test -eq 0 ]] && {
					primality_checker=$(( primality_checker + 1 ))
				}

				# Stop checking $mersenne_numbers since it fails primality test
				[[ $primality_checker -gt 1 ]] && break
			done

			# Count found mersenne primes
			[[ $primality_checker -eq 1 || $prime_numbers == 2 ]] && {
				found_mersenne_primes=$(( found_mersenne_primes + 1 ))
				mersenne_prime_largest="Largest Mersenne prime found M($prime_numbers) = $mersenne_numbers"
				printf 'M(%s) = %s\n' "$prime_numbers" "$mersenne_numbers"
			}
		done

		# Show number of mersenne primes found
		printf '\n'
		print_success "Total Mersenne primes found = ${found_mersenne_primes}"
		printf '\n'

		# Show the largest mersenne prime found
		[[ $found_mersenne_primes -gt 0 ]] && {
			print_success "${mersenne_prime_largest}"
			printf '\n'
		}

		# Show the time taken to process
		time_suffix="seconds"
		[[ $SECONDS -eq 1 ]] && time_suffix="${time_suffix%s}"
		print_success "Total time taken = ${SECONDS} ${time_suffix}"
	}

	# Show total time taken on program cancellation
	show_on_exit() {
		time_suffix="seconds"
		[[ $SECONDS -eq 1 ]] && time_suffix="${time_suffix%s}"
		printf '\n\n'
		print_error "Aborted"
		printf '\n'
		print_success "Total Time taken = ${SECONDS} ${time_suffix}"
		exit 1
	}

	check_input_option() {
		for primary_options in "${@:1}"; do
			case "$primary_options" in
				-h | --help)
					print_help
				;;
				-it | --iteration)
					user_iteration="$2"
					integer_checker="${user_iteration//[0-9]}"
					integer_checker="${integer_checker//[[:space:]]}"

					[[ -n $integer_checker || -z $user_iteration ]] && {
						print_error "Input iterations as positive integers"
						exit 1
					}

					[[ $user_iteration -ge 32 ]] && {
						print_warning "This may take a while"
						printf '\n'
					}

					# Switch to bc since bash overflows at > 2 ^ 62
					[[ $user_iteration -ge 63 ]] && {
						[[ ! $(type -p bc) ]] && print_missing_dependencies "bc"
						print_warning "Switching from bash to bc"
						print_aligned "Bash overflows at 2 ^ 63"
						printf '\n'
					}

					prime_test_benchmark "$@"
					exit 0
				;;
				-V | --version)
					print_version
				;;
				-*)
					[[ -z ${primary_options#*\-} || -z ${primary_options/\-\-*} ]] && {
						print_error "Unrecognized option '${primary_options}'"
						print_notification
					}

					print_error "Invalid option -- '${primary_options#*\-}'"
					print_notification
				;;
				*)
					print_error "Unrecognized option '${primary_options}'"
					print_notification
				;;
			esac
		done
	}

	trap 'show_on_exit' 1 2 3 15
	print_no_argument "$@"
	check_input_option "$@"
	exit
}

#--------------------------------------------------------------
# Platform: Device Agnostic
# Dependencies: bash
#--------------------------------------------------------------
dotfiles() {
	print_help() {
echo -e "\033[1;97mNAME\033[00m
	$SCRIPT_NAME - dotfile management tool.

\033[1;97mSYNOPSIS\033[00m
	$SCRIPT_NAME [OPTION]

\033[1;97mDESCRIPTION\033[00m
	Replaces the dotfiles of the specified program with a custom version
	downloaded from <https://github.com/teth3r/dotfiles/>. Be sure to 
	perform a backup of existing dotfiles before running this program.

	\033[1;97m-b, --bashrc\033[00m
		Downloads and adds custom .bashrc.

	\033[1;97m-fi, --firefox\033[00m
		Downloads and adds custom user.js for Firefox.

	\033[1;97m-h,  --help\033[00m
		display this help message and exit.

	\033[1;97m-kd, --kitty-dark\033[00m
		Downloads and adds custom kitty.conf with dark theme.

	\033[1;97m-kl, --kitty-light\033[00m
		Downloads and adds custom kitty.conf with light theme.

	\033[1;97m-m, --mkshrc\033[00m
		Downloads and adds custom mkshrc file for Android.

	\033[1;97m-td, --termux-dark\033[00m
		Downloads and adds custom prop files with dark theme for Termux.

	\033[1;97m-tl, --termux-light\033[00m
		Downloads and adds custom prop files with light theme for Termux.

	\033[1;97m-t, --tmux\033[00m
		Downloads and adds custom .tmux.conf.

	\033[1;97m-u, --urxvt\033[00m
		Downloads and adds custom .Xresources.

	\033[1;97m-v, --vimrc\033[00m
		Downloads and adds custom .vimrc.

	\033[1;97m-vc, --vim-color\033[00m
		Downloads and adds custom vim colorscheme.

	\033[1;97m-V,  --version\033[00m
		output version information and exit.

\033[1;97mAUTHOR\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.
	Written by Kolade Ayomide Olanrewaju.

\033[1;97mREPORTING BUGS\033[00m
	Create a new issue at <https://github.com/teth3r/tether/>.

\033[1;97mCOPYRIGHT\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.

tether $SCRIPT_VERSION"
exit 0
	}

	check_dependencies() {
		# Check for required dependencies
		[[ ! $(type -p "wget") && ! $(type -p busybox) ]] && {
			print_missing_dependencies "wget"
		}

		[[ $(type -p busybox) ]] && WGET="busybox wget"
		[[ $(type -p wget) ]] && WGET="wget"

		# Check for internet connection
		[[ ! $(ping -c4 voidlinux.org 2>/dev/null) ]] && {
			print_error "Failed to detect an internet connection"
			exit 1
		}
	}

	check_input_option() {
		for primary_options in "${@:1}"; do
			case "$primary_options" in
				-b | --bashrc)
					check_dependencies "$@"

					unset exit_status
					[[ -d /system/app/ && -f /system/build.prop ]] && {
						print_not_root_user "$@"

						mkdir -p "$MODULE_DIRECTORY/system/etc/bash" 2>/dev/null
						bash_file="$MODULE_DIRECTORY/system/etc/bash/.bashrc"

						$WGET "https://github.com/teth3r/dotfiles/raw/master/bashrc" -O "$bash_file" &>/dev/null && exit_status=0

						[[ -n $exit_status && $exit_status -eq 0 ]] && {
							print_success "Finished updating '$MODULE_DIRECTORY/system/etc/bash/.bashrc'"
							exit 0
						}

						print_error "Failed to update '$MODULE_DIRECTORY/system/etc/bash/.bashrc'"
						exit 1
					}

					# Handles linux install with missing HOME_DIR
					[[ ! -d "${HOME}" && ! -d /system/app ]] || [[ -z "${HOME}" ]] && {
						print_error "Failed to update '~/.bashrc'"
						exit 1
					}

					bash_file="${HOME}/.bashrc"
					$WGET "https://github.com/teth3r/dotfiles/raw/master/bashrc" -O "$bash_file" &>/dev/null && exit_status=0

					[[ -n $exit_status && $exit_status -eq 0 ]] && {
						print_success "Finished updating '${HOME}/.bashrc'"
						exit 0
					}

					print_error "Failed to update '${HOME}/.bashrc'"
					exit 1
				;;
				-fi | --firefox)
					check_dependencies "$@"

					[[ $(type -p firefox) || $(pm list packages "org.mozilla.fennec_fdroid" 2>/dev/null) ]] && {
						unset exit_status
						unset user_js
						# Handles Android
						[[ -d /system/app/ && -f /system/build.prop ]] && {
							for firefox_dir in /data/data/org.mozilla.fennec_fdroid/files/mozilla/*default*; do
								[[ -f $firefox_dir/prefs.js || -f $firefox_dir/storage.sqlite || -f $firefox_dir/pkcs11.txt ]] && {
									user_js="$firefox_dir/user.js"
									break
								}
							done
						}

						# Handles Linux desktop
						[[ ! -d /system/app/ ]] && {
							for firefox_dir in /home/"${SUDO_USER:=$USER}"/.mozilla/firefox/*default*; do
								[[ -f $firefox_dir/prefs.js || -f $firefox_dir/storage.sqlite || -f $firefox_dir/pkcs11.txt ]] && {
									user_js="$firefox_dir/user.js"
									break
								}
							done
						}

						# Return an error if Firefox is installed but $firefox_dir doesn't exist
						[[ -z $user_js ]] && {
							user_js="user.js"
							print_error "Failed to update '$user_js'"
							exit 1
						}

						$WGET "https://github.com/teth3r/dotfiles/raw/master/user.js" -O "$user_js" &>/dev/null && exit_status=0

						[[ -n $exit_status && $exit_status -eq 0 ]] && {
							[[ -d /system/app/ && -f /system/build.prop ]] && {
								chmod 644 "$user_js" 2>/dev/null
							}

							[[ ! -d /system/app/ ]] && {
								chown "${SUDO_USER:=$USER}":"${SUDO_USER:=$USER}" "$user_js" 2>/dev/null
							}
							print_success "Finished updating '$user_js'"
							exit 0
						}

						print_error "Failed to update '$user_js'"
						exit 1
					}

					print_missing_dependencies "Firefox"
					exit 1
				;;
				-h | --help)
					print_help
				;;
				-kd | --kitty-dark)
					check_dependencies "$@"

					[[ $(type -p kitty) ]] && {
						unset exit_status
						# Handles linux install with missing user
						[[ ! -d "/home/${SUDO_USER:=$USER}" && ! -d /system/app ]] && {
							print_error "Failed to update '~/.config/kitty/kitty.conf'"
							exit 1
						}

						mkdir -p "/home/${SUDO_USER:=$USER}/.config/kitty" 2>/dev/null
						kitty_file="/home/${SUDO_USER:=$USER}/.config/kitty/kitty.conf"

						$WGET "https://github.com/teth3r/dotfiles/raw/master/kitty_dark.conf" -O "$kitty_file" &>/dev/null && exit_status=0

						[[ -n $exit_status && $exit_status -eq 0 ]] && {
							chown "${SUDO_USER:=$USER}":"${SUDO_USER:=$USER}" /home/"${SUDO_USER:=$USER}"/.config/kitty/kitty.conf 2>/dev/null
							print_success "Finished updating '/home/${SUDO_USER:=$USER}/.config/kitty/kitty.conf'"
							exit 0
						}

						print_success "Failed to update '/home/${SUDO_USER:=$USER}/.config/kitty/kitty.conf'"
						exit 1
					}

					print_missing_dependencies "Kitty"
					exit 1
				;;
				-kl | --kitty-light)
					check_dependencies "$@"

					[[ $(type -p kitty) ]] && {
						unset exit_status
						# Handles linux install with missing user
						[[ ! -d "/home/${SUDO_USER:=$USER}" && ! -d /system/app ]] && {
							print_error "Failed to update '~/.config/kitty/kitty.conf'"
							exit 1
						}

						mkdir -p "/home/${SUDO_USER:=$USER}/.config/kitty" 2>/dev/null
						kitty_file="/home/${SUDO_USER:=$USER}/.config/kitty/kitty.conf"

						$WGET "https://github.com/teth3r/dotfiles/raw/master/kitty_light.conf" -O "$kitty_file" &>/dev/null && exit_status=0

						[[ -n $exit_status && $exit_status -eq 0 ]] && {
							chown "${SUDO_USER:=$USER}":"${SUDO_USER:=$USER}" /home/"${SUDO_USER:=$USER}"/.config/kitty/kitty.conf 2>/dev/null
							print_success "Finished updating '/home/${SUDO_USER:=$USER}/.config/kitty/kitty.conf'"
							exit 0
						}

						print_success "Failed to update '/home/${SUDO_USER:=$USER}/.config/kitty/kitty.conf'"
						exit 1
					}

					print_missing_dependencies "Kitty"
					exit 1
				;;
				-m | --mkshrc)
					check_dependencies "$@"

					[[ -d /system/app/ && -f /system/build.prop ]] && {
						unset exit_status
						print_not_root_user "$@"

						mkdir -p "$MODULE_DIRECTORY/system/etc" 2>/dev/null
						mksh_file="$MODULE_DIRECTORY/system/etc/mkshrc"

						$WGET "https://github.com/teth3r/dotfiles/raw/master/mkshrc" -O "$mksh_file" &>/dev/null && exit_status=0

						[[ -n $exit_status && $exit_status -eq 0 ]] && {
							print_success "Finished updating '$MODULE_DIRECTORY/system/etc/mkshrc'"
							exit 0
						}

						print_error "Failed to update '$MODULE_DIRECTORY/system/etc/mkshrc'"
						exit 1
					}

					print_os_error
					exit 1
				;;
				-td | --termux-dark)
					check_dependencies "$@"

					[[ ! -d /system/app ]] && print_os_error

					[[ $(pm list packages "com.termux" 2>/dev/null) && -d $TERMUX_DIRECTORY ]] && {
						print_not_root_user "$@"

						unset exit_status
						# Update termux.properties
						mkdir -p "$TERMUX_DIRECTORY/home/.termux" 2>/dev/null
						config_file="$TERMUX_DIRECTORY/home/.termux/termux.properties"

						$WGET "https://github.com/teth3r/dotfiles/raw/master/termux.properties" -O "$config_file" &>/dev/null && exit_status=0

						[[ -n $exit_status && $exit_status -eq 0 ]] && {
							print_success "Finished updating '$TERMUX_DIRECTORY/home/.termux/termux.properties'"
						}

						[[ -z $exit_status ]] && {
							print_error "Failed to update '$TERMUX_DIRECTORY/home/.termux/termux.properties'"
						}

						unset exit_status
						# Update colors.properties
						mkdir -p "$TERMUX_DIRECTORY/home/.termux" 2>/dev/null
						color_file="$TERMUX_DIRECTORY/home/.termux/colors.properties"

						$WGET "https://github.com/teth3r/dotfiles/raw/master/colors_dark.properties" -O "$color_file" &>/dev/null && exit_status=0

						[[ -n $exit_status && $exit_status -eq 0 ]] && {
							print_success "Finished updating '$TERMUX_DIRECTORY/home/.termux/colors.properties'"
						}

						[[ -z $exit_status ]] && {
							print_error "Failed to update '$TERMUX_DIRECTORY/home/.termux/colors.properties'"
						}

						unset exit_status
						# Update usr/etc/.bashrc
						mkdir -p "$TERMUX_DIRECTORY/home" 2>/dev/null
						bash_file="$TERMUX_DIRECTORY/home/.bashrc"

						$WGET "https://github.com/teth3r/dotfiles/raw/master/bashrc" -O "$bash_file" &>/dev/null && exit_status=0

						[[ -n $exit_status && $exit_status -eq 0 ]] && {
							rm -rf "$TERMUX_DIRECTORY"/usr/etc/motd* 2>/dev/null
							print_success "Finished updating '$TERMUX_DIRECTORY/home/.bashrc'"
							exit 0
						}

						print_error "Failed to update '$TERMUX_DIRECTORY/home/.bashrc'"
						exit 1
					}

					[[ $(pm list packages "com.termux" 2>/dev/null) && ! -d $TERMUX_DIRECTORY ]] && {
						print_error "Cannot stat '$TERMUX_DIRECTORY': No such file or directory"
						print_aligned "Try running 'Termux' at least once"
						exit 1
					}

					print_missing_dependencies "termux"
					exit 1
				;;
				-tl | --termux-light)
					check_dependencies "$@"

					[[ ! -d /system/app ]] && print_os_error

					[[ $(pm list packages "com.termux" 2>/dev/null) && -d $TERMUX_DIRECTORY ]] && {
						print_not_root_user "$@"

						unset exit_status
						# Update termux.properties
						mkdir -p "$TERMUX_DIRECTORY/home/.termux" 2>/dev/null
						config_file="$TERMUX_DIRECTORY/home/.termux/termux.properties"

						$WGET "https://github.com/teth3r/dotfiles/raw/master/termux.properties" -O "$config_file" &>/dev/null && exit_status=0

						[[ -n $exit_status && $exit_status -eq 0 ]] && {
							print_success "Finished updating '$TERMUX_DIRECTORY/home/.termux/termux.properties'"
						}

						[[ -z $exit_status ]] && {
							print_error "Failed to update '$TERMUX_DIRECTORY/home/.termux/termux.properties'"
						}

						unset exit_status
						# Update colors.properties
						mkdir -p "$TERMUX_DIRECTORY/home/.termux" 2>/dev/null
						color_file="$TERMUX_DIRECTORY/home/.termux/colors.properties"

						$WGET "https://github.com/teth3r/dotfiles/raw/master/colors_light.properties" -O "$color_file" &>/dev/null && exit_status=0

						[[ -n $exit_status && $exit_status -eq 0 ]] && {
							print_success "Finished updating '$TERMUX_DIRECTORY/home/.termux/colors.properties'"
						}

						[[ -z $exit_status ]] && {
							print_error "Failed to update '$TERMUX_DIRECTORY/home/.termux/colors.properties'"
						}

						unset exit_status
						# Update usr/etc/.bashrc
						mkdir -p "$TERMUX_DIRECTORY/home" 2>/dev/null
						bash_file="$TERMUX_DIRECTORY/home/.bashrc"

						$WGET "https://github.com/teth3r/dotfiles/raw/master/bashrc" -O "$bash_file" &>/dev/null && exit_status=0

						[[ -n $exit_status && $exit_status -eq 0 ]] && {
							rm -rf "$TERMUX_DIRECTORY"/usr/etc/motd* 2>/dev/null
							print_success "Finished updating '$TERMUX_DIRECTORY/home/.bashrc'"
							exit 0
						}

						print_error "Failed to update '$TERMUX_DIRECTORY/home/.bashrc'"
						exit 1
					}

					[[ $(pm list packages "com.termux" 2>/dev/null) && ! -d $TERMUX_DIRECTORY ]] && {
						print_error "Cannot stat '$TERMUX_DIRECTORY': No such file or directory"
						print_aligned "Try running 'Termux' at least once"
						exit 1
					}

					print_missing_dependencies "termux"
					exit 1
				;;
				-tm | --tmux)
					check_dependencies "$@"

					[[ $(type -p tmux) ]] && {
						unset exit_status
						# Handles linux install with missing HOME_DIR
						[[ ! -d "${HOME}" && ! -d /system/app ]] || [[ -z "${HOME}" ]] && {
							print_error "Failed to update '~/.tmux.conf'"
							exit 1
						}

						tmux_file="${HOME}/.tmux.conf"
						$WGET "https://github.com/teth3r/dotfiles/raw/master/tmux.conf" -O "$tmux_file" &>/dev/null && exit_status=0

						[[ -n $exit_status && $exit_status -eq 0 ]] && {
							print_success "Finished updating '${HOME}/.tmux.conf'"
							exit 0
						}

						print_error "Failed to update '${HOME}/.tmux.conf'"
						exit 1
					}

					print_missing_dependencies "tmux"
					exit 1
				;;
				-u | --urxvt)
					check_dependencies "$@"

					[[ $(type -p urxvt) ]] && {
						unset exit_status
						# Handles linux install with missing user
						[[ ! -d "/home/${SUDO_USER:=$USER}" && ! -d /system/app ]] && {
							print_error "Failed to update '~/.Xresources'"
							exit 1
						}

						urxvt_file="/home/${SUDO_USER:=$USER}/.Xresources"

						$WGET "https://github.com/teth3r/dotfiles/raw/master/Xresources" -O "$urxvt_file" &>/dev/null && exit_status=0

						[[ -n $exit_status && $exit_status -eq 0 ]] && {
							chown "${SUDO_USER:=$USER}":"${SUDO_USER:=$USER}" /home/"${SUDO_USER:=$USER}"/.Xresources 2>/dev/null
							xrdb /home/"${SUDO_USER:=$USER}"/.Xresources 2>/dev/null

							print_success "Finished updating '/home/${SUDO_USER:=$USER}/.Xresources'"
							exit 0
						}

						print_success "Failed to update '/home/${SUDO_USER:=$USER}/.Xresources'"
						exit 1
					}

					print_missing_dependencies "rxvt-unicode"
					exit 1
				;;
				-v | --vimrc)
					check_dependencies "$@"

					[[ $(type -p vim) ]] && {
						unset exit_status
						# Handles linux install with missing HOME_DIR
						[[ ! -d "${HOME}" && ! -d /system/app ]] || [[ -z "${HOME}" ]] && {
							print_error "Failed to update '~/.bashrc'"
							exit 1
						}

						vimrc_file="${HOME}/.vimrc"
						$WGET "https://github.com/teth3r/dotfiles/raw/master/vimrc" -O "$vimrc_file" &>/dev/null && exit_status=0

						[[ -n $exit_status && $exit_status -eq 0 ]] && {
							print_success "Finished updating '${HOME}/.vimrc'"
							exit 0
						}

						print_error "Failed to update '${HOME}/.vimrc'"
						exit 1
					}

					print_missing_dependencies "vim"
					exit 1
				;;
				-vc | --vim-color)
					check_dependencies "$@"

					[[ $(type -p vim) ]] && {
						print_not_root_user

						for vim_dir in /usr/share/vim/*/colors; do
							unset exit_status
							[[ -d $vim_dir ]] && {
								vim_color_file="$vim_dir/tether.vim"
								$WGET "https://github.com/teth3r/dotfiles/raw/master/tether.vim" -O "$vim_color_file" &>/dev/null && exit_status=0

								[[ -n $exit_status && $exit_status -eq 0 ]] && {
									print_success "Finished updating '$vim_color_file'"
								}

								[[ -z $exit_status ]] && {
									print_error "Failed to update '$vim_color_file'"
									exit 1
								}
							}
						done
						exit 0
					}

					print_missing_dependencies "vim"
					exit 1
				;;
				-V | --version)
					print_version
				;;
				-*)
					[[ -z ${primary_options#*\-} || -z ${primary_options/\-\-*} ]] && {
						print_error "Unrecognized option '${primary_options}'"
						print_notification
					}

					print_error "Invalid option -- '${primary_options#*\-}'"
					print_notification
				;;
				*)
					for secondary_options in "${@:2}"; do
						case "$secondary_options" in
							-h | --help)
								print_help
							;;
						esac
					done

					print_error "Unrecognized option '${primary_options}'"
					print_notification
				;;
			esac
		done
	}
	trap 'run_on_exit' 1 2 3 15
	print_no_argument "$@"
	check_input_option "$@"
	exit
}

#--------------------------------------------------------------
# Platform: Device Agnostic
# Dependencies: mkdir, ls, 7zip, 7zip-unrar, bsdtar
#--------------------------------------------------------------
extract() {
	print_help() {
echo -e "\033[1;97mNAME\033[00m
	$SCRIPT_NAME - extract compressed files from archive.

\033[1;97mSYNOPSIS\033[00m
	$SCRIPT_NAME [FILE(s)...]
	$SCRIPT_NAME [OPTION]

\033[1;97mDESCRIPTION\033[00m
	\033[1;97m$SCRIPT_NAME\033[00m will extract all the files in the specified [FILE(s)...] to
	a newly created folder in the current directory. The created folder
	will be named according to the archive file being extracted.
	For instance archive1.zip will extract into archive1/.
	\033[1;97mNOTE:\033[00m If a folder already exist with the archive name,
	the archive name + a random number will be used as the folder name
	instead i.e archive1_30002/. 

	\033[1;97m-h, --help\033[00m
		display this help message and exit.

	\033[1;97m-V, --version\033[00m
		output version information and exit.

\033[1;97mAUTHOR\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.
	Written by Kolade Ayomide Olanrewaju.

\033[1;97mREPORTING BUGS\033[00m
	Create a new issue at <https://github.com/teth3r/tether/>.

\033[1;97mCOPYRIGHT\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.

tether $SCRIPT_VERSION"
exit 0
	}

	check_dependencies() {
		# Prevent bad system call error as non-root user
		[[ -d "/system/app/" && $EUID -gt 0 ]] && print_not_root_user

		# Check for required dependencies
		for mis_dep in mkdir ls; do
			[[ ! $(type -p "$mis_dep") ]] && {
				print_missing_dependencies "$mis_dep"
			}
		done
	}

	failed_to_extract() {
		printf '\n'
		rm -rf "$folder_name" 2>/dev/null
		exit_status=1
	}

	check_input_argument() {
		for archive_file in "${@:1}"; do
			unset exit_status
			case "$archive_file" in
				*)
					# Set name of archive folder
					folder_name="${archive_file##*/}"
					folder_name="${folder_name%.*}"

					# Handles tar.xz
					folder_name="${folder_name%.tar}"

					# Handles img.xz
					folder_name="${folder_name%.img}"

					# Use original filename if $folder_name is empty
					# Only occurs if $archive_file is a hidden file
					[[ -z $folder_name ]] && {
						folder_name="${archive_file##*/}_${RANDOM}"
					}

					# Add random number if file exist with $folder_name
					[[ -e $folder_name ]] && {
						folder_name="${folder_name}_${RANDOM}"
					}

					# Handles if $archive_file is a folder
					[[ -d $archive_file ]] && {
						printf '\n'
						print_error "Cannot extract '$archive_file': Not a valid archive"
						exit_status=1
					}

					# Handles if $archive_file doesn't exist
					[[ ! -e $archive_file ]] && {
						printf '\n'
						print_error "Cannot extract '$archive_file': No such file"
						exit_status=1
					}

					# Handles .rar archive files
					[[ -f $archive_file && $archive_file =~ .rar ]] && {
						[[ ! $(type -p 7zip-unrar) ]] && print_missing_dependencies "7zip-unrar"

						# Make $folder_name
						mkdir -p "$folder_name" 2>/dev/null || print_write_error "$folder_name"

						7zip-unrar x "$archive_file" -y -mmt"$CPU_CORE_COUNT" -o"$folder_name"  || failed_to_extract
					}

					# Handles archive files
					[[ -f $archive_file && $archive_file =~ .7z|.xz|.gz|.tar|.tar.xz ]] && {
						[[ ! $(type -p 7z) ]] && print_missing_dependencies "7zip"

						# Make $folder_name
						mkdir -p "$folder_name" 2>/dev/null || print_write_error "$folder_name"

						7z x "$archive_file" -y -mmt"$CPU_CORE_COUNT" -o"$folder_name" 2>/dev/null || failed_to_extract
					}

					# Handles every other archive type
					[[ -f $archive_file || $exit_status -eq 1 ]] && ! [[ $archive_file =~ .7z|.rar|.tar.xz ]] && {
						# Handles running without bsdtar but with busybox installed
						[[ ! $(type -p bsdtar) ]] && [[ $(type -p busybox) ]] && {
							[[ $archive_file =~ .tar ]] && {
								# Make $folder_name
								mkdir -p "$folder_name" 2>/dev/null || print_write_error "$folder_name"

								busybox tar -xf "${archive_file}" -C "${folder_name}" || failed_to_extract
							}

							[[ $archive_file =~ .zip ]] && {
								# Make $folder_name
								mkdir -p "$folder_name" 2>/dev/null || print_write_error "$folder_name"
								current_dir="$PWD"

								cp -rf "${archive_file}" "${folder_name}" 2>/dev/null || print_file_write_error "${archive_file}"
								cd "${folder_name}" 2>/dev/null || print_dir_change_error "${folder_name}"

								busybox unzip -q "${archive_file}" 2>/dev/null || failed_to_extract
								rm -r "${archive_file##*\/}" 2>/dev/null
								cd "$current_dir" 2>/dev/null || print_dir_change_error "$current_dir"
							}

							[[ $archive_file =~ .gz|.xz ]] && {
								# Make $folder_name
								mkdir -p "$folder_name" 2>/dev/null || print_write_error "$folder_name"
								current_dir="$PWD"
								
								cp -rf "${archive_file}" "${folder_name}" 2>/dev/null || print_file_write_error "${archive_file}"
								cd "${folder_name}" 2>/dev/null || print_dir_change_error "${folder_name}"

								[[ $archive_file =~ .xz ]] && {
									busybox xz -d "${archive_file}" 2>/dev/null || failed_to_extract
								}
				
								[[ $archive_file =~ .gz ]] && {
									busybox gzip -d "${archive_file}" 2>/dev/null || failed_to_extract
								}
								cd "$current_dir" 2>/dev/null || print_dir_change_error "$current_dir"
							}

							# Alternative to `ls -A "$folder_name"`
							# Check for successful decompression
							[[ $(printf '%s\n' "$folder_name/"*) != "$folder_name/*" || $(printf '%s\n' "$folder_name/".*) != "$folder_name/.*" ]] && {
								printf '\n'
								print_success "Extracted '$archive_file' to '$folder_name'"
								exit_status=0
								return
							}
						}

						[[ ! $(type -p bsdtar) ]] && print_missing_dependencies "bsdtar"

						# Make $folder_name
						mkdir -p "$folder_name" 2>/dev/null || print_write_error "$folder_name"

						bsdtar -xf "$archive_file" -C "$folder_name" 2>/dev/null || failed_to_extract
					}

					# Alternative to `ls -A "$folder_name"`
					# Check for successful decompression
					[[ $(printf '%s\n' "$folder_name/"*) != "$folder_name/*" || $(printf '%s\n' "$folder_name/".*) != "$folder_name/.*" ]] && {
						printf '\n'
						print_success "Extracted '$archive_file' to '$folder_name'"
						exit_status=0
					}

					# Handles errors
					[[ $exit_status -eq 1 ]] && {
						print_error "Failed to extract '$archive_file'"
					}
				;;
			esac
		done

		# Show last exit status
		exit "${exit_status:=1}"
	}

	trap 'remove_file_on_exit "$folder_name"' 1 2 3 15
	print_no_argument "$@"
	input_option_type_one "$@"
	check_dependencies "$@"
	check_input_argument "$@"
	exit
}

#--------------------------------------------------------------
# Platform: Device Agnostic
# Dependencies: wget, find, lltag, iconv
#--------------------------------------------------------------
lyrics() {
	print_help() {
echo -e "\033[1;97mNAME\033[00m
	$SCRIPT_NAME - batch download lrc files.

\033[1;97mSYNOPSIS\033[00m
	$SCRIPT_NAME [FILE(s)...]
	$SCRIPT_NAME [OPTION]

\033[1;97mDESCRIPTION\033[00m
	\033[1;97m$SCRIPT_NAME\033[00m reads the audio tags of the specified [FILE(s)...] and searches for
	and downloads the matching lrc file. The resulting lrc file will be
	named according to the specified file i.e music1.flac -> music1.lrc.

	\033[1;97m-h, --help\033[00m
		display this help message and exit.

	\033[1;97m-V, --version\033[00m
		output version information and exit.

\033[1;97mAUTHOR\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.
	Written by Kolade Ayomide Olanrewaju.

\033[1;97mREPORTING BUGS\033[00m
	Create a new issue at <https://github.com/teth3r/tether/>.

\033[1;97mCOPYRIGHT\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.

tether $SCRIPT_VERSION"
exit 0
	}

	check_dependencies() {
		# Check for required dependencies
		for mis_dep in lltag wget find iconv ping; do
			[[ ! $(type -p "$mis_dep") ]] && {
				print_missing_dependencies "$mis_dep"
			}
		done

		# Declare source file
		file_name="$1"

		# Only run as non root
		print_not_normal_user "$@"

		# Check for internet connection
		[[ ! $(ping -c4 voidlinux.org 2>/dev/null) ]] && {
			print_error "Failed to detect an internet connection"
			exit 1
		}
	}

	failed_to_fetch() {
		# recheck internet connection before proceeding
		[[ ! $(ping -c2 voidlinux.org 2>/dev/null) ]] && {
			print_error "Failed to detect an internet connection"
			exit 1
		}
		failed_fetch="true"
		skip="true"
		exit_status=1
		return
	}

	content_loader() {
		user_agent_string="User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:121.0) Gecko/20100101 Firefox/121.0"
		wget --header "$user_agent_string" "$1" --output-document - 2>/dev/null || failed_to_fetch "$@"
	}

	fetch_song_tags() {
		# Extract artist tag from file
		artist="$(lltag --show-tags ARTIST "$parsed_file" 2>/dev/null)"
		artist="${artist//*"ARTIST="}"
		artist="${artist//*"artist="}"
		artist="${artist//*"Artist="}"

		# Extract title tag from file
		title="$(lltag --show-tags TITLE "$parsed_file" 2>/dev/null)"
		title="${title//*"TITLE="}"
		title="${title//*"title="}"
		title="${title//*"Title="}"

		# Fixes broken --show-tags parsing in `lltag`
		[[ ${parsed_file//*\/} == *=* ]] && {
			title="$(lltag -S "$parsed_file" 2>/dev/null)"
			title="${title//*"TITLE="}"
			title="${title//[A-Z]=*}"
		}
	}

	check_audio_files() {
		# Only process audio files
		! [[ $parsed_file =~ .wav|.aac|.vorbis|.flac|.m4a|.mp3|.ogg|.opus|.lrc ]] && [[ ! -d $parsed_file ]] && {
			print_error "'$parsed_file' is not a valid or supported audio file"
			printf '\n'
			skip="true"
			exit_status=1
			return
		}

		# Skip .lrc files
		[[ $parsed_file  =~ .lrc ]] && {
			check_lrc="$(< "$lrc_file")"

			# Check if .lrc file is empty
			[[ -n $check_lrc ]] && {
				print_warning "'$parsed_file' is a Lyrics file"
				printf '\n'
				skip="true"
				exit_status=0
				return
			}

			# Delete .lrc file if it is empty
			print_error "'$parsed_file' is not a valid Lyrics file"
			printf '\n'
			rm "$parsed_file" 2>/dev/null
			skip="true"
			exit_status=1
			return
		}

		# Check if .lrc file already exists
		[[ -f $lrc_file ]] && ! [[ $parsed_file =~ .lrc ]] && {
			check_lrc="$(< "$lrc_file")"
			[[ -n $check_lrc ]] && {
				print_warning "Lyrics file for '$parsed_file' already exists"
				printf '\n'
				skip="true"
				exit_status=0
				return
			}
		}

		# Fetch song tags from audio file
		fetch_song_tags "$@"

		# Handles missing tags
		[[ -z $artist || -z $title ]] && {
			print_error "'$parsed_file' file has incorrect or invalid metadata"
			printf '\n'
			skip="true"
			exit_status=1
			return
		}

		# Handles valid files
		[[ $parsed_file =~ .wav|.aac|.vorbis|.flac|.m4a|.mp3|.ogg|.opus ]] && {
			valid_file="true"
		}
	}

	lrclib_parser() {
		# Create variables with song tags
		fetch_song_tags "$@"

		# Check if run has been skipped
		[[ $skip == "true" ]] && return

		# Convert to lowercase
		artist="${artist,,}"

		# Replace all whitespace with +
		artist="${artist//[[:space:]]/"+"}"
		artist="${artist//"++"/"+"}"

		# Useful for "artists" like Tydolla$ign, A$APRocky
		artist="${artist//"$"/"s"}"
		fallback_artist="${artist}"

		# Remove diacritics from strings
		artist="$(printf '%s\n' "$artist" | iconv -f utf8 -t ascii//TRANSLIT)"

		# Useful for CJK characters
		[[ -z $artist || $artist == *"???"* ]] && artist="${fallback_artist}"

		# Sanitize artist string
		for sanitize in "(" ")" "[" "]" "!" "?" "=" "&" "#" ":" ";" "/" "," "'" '“' '”' "‘" "’" "+feat." "+featuring" "+ft." "." "+with"; do
			[[ $sanitize =~ "+feat."|"+ft."|"+featuring"|","|";"|"+with"|'“'|'”'|"‘"|"’" ]] && {
				artist="${artist//"$sanitize"*}"
			}
			artist="${artist//"$sanitize"}"
		done

		# Fixes issues with Marina's music
		[[ $artist == "marina+and+the+diamonds" ]] && {
			artist="${artist/"marina+and+the+diamonds"/"marina"}"
		}

		# Convert to lowercase
		title="${title,,}"

		# Replace all whitespace with +
		title="${title//[[:space:]]/"+"}"
		title="${title//"++"/"+"}"

		title="${title//"$"/"s"}"
		fallback_title="${title}"

		# Remove diacritics from strings
		title="$(printf '%s\n' "$title" | iconv -f utf8 -t ascii//TRANSLIT)"

		# Useful for CJK characters
		[[ -z $title || $title == *"???"* ]] && title="${fallback_title}"

		# Sanitize title string
		for sanitize in "(" ")" "[" "]" "?" "&" "#" ":" ";" "*" "-" "/" "," "." "'" '“' '”' "‘" "’" "+explicit" "+digital+bonus+track" "+bonus+track" "+demo+version" "+acoustic+version" "+original+version"; do
			[[ $sanitize =~ '“'|'”'|"‘"|"’" ]] && {
				title="${title//"$sanitize"*}"
			}
			title="${title//"$sanitize"}"
		done

		# Skip if missing tags, useful for CJK characters
		[[ -z $artist || -z $title ]] && {
			missing_lyrics="true"
			skip="true"
			exit_status=1
			return
		}

		# Handles double spacing
		artist="${artist//[[:space:]]/"+"}"
		artist="${artist//"++"/"+"}"

		title="${title//[[:space:]]/"+"}"
		title="${title//"++"/"+"}"

		url="https://lrclib.net/api/search?track_name=${title}&artist_name=${artist}"

		output="$(content_loader "$url")"

		# Check for internet connection problems
		[[ -z $output ]] && failed_to_fetch "$@"

		# Check if website gave a valid response
		[[ $output != *"TrackNotFound"* && $output != "[]" ]] &&
		# Only use this parser if synced lyrics exist
		[[ $output == *"\"syncedLyrics\":\""* && $output == *\[[0-9]*:* ]] && {
			# Sanitize output string
			output="${output//*"\"syncedLyrics\":\""}"
			output="${output//"\"}]"*}"
			output="${output//"\\\""}"
			output="${output//"\"}"*}"

			printf '%b\n' "${output}" > "$lrc_file"
			exit_status=0
			return
		}

		# Check for missing lyrics page
		[[ $output == "[]" || $output == *"TrackNotFound"* || $output == *"\"instrumental\": true"* || $output == *"\"syncedLyrics\":null"* ]] && {
			missing_lyrics="true"
			skip="true"
			exit_status=1
			return
		}

		# Act as a catch all or `else`
		missing_lyrics="true"
		unset failed_fetch
		exit_status=1

		# Add delay between each run to prevent a captcha response
		read -rt "1" <> <(:) || :
	}

	azlyrics_parser() {
		# Create variables with song tags
		fetch_song_tags "$@"

		# Check if run has been skipped
		[[ $skip == "true" ]] && return

		# Convert to lowercase
		artist="${artist,,}"

		# Remove all white space
		artist="${artist//[[:space:]]}"
		fallback_artist="${artist}"

		# Remove diacritics from strings
		artist="$(printf '%s\n' "$artist" | iconv -f utf8 -t ascii//TRANSLIT)"

		# Useful for CJK characters
		[[ -z $artist || $artist == *"???"* ]] && artist="${fallback_artist}"

		# Sanitize artist string
		for sanitize in "(" ")" "[" "]" "-" "!" "?" "=" "&" "#" ":" ";" "'" "+" '“' '”' "‘" "’" "/" "," "feat." "featuring" "ft." "." "with"; do
			[[ $sanitize =~ "feat."|"ft."|"featuring"|","|";"|"with" ]] && {
				artist="${artist//"$sanitize"*}"
			}
			artist="${artist//"$sanitize"}"
		done

		# Fixes issues with Marina's music
		[[ $artist == "marina" ]] && {
			artist="${artist/"marina"/"marinathediamonds"}"
		}

		[[ $artist == "marinaandthediamonds" ]] && {
			artist="${artist/"marinaandthediamonds"/"marinathediamonds"}"
		}

		# Useful for "artists" like Tydolla$ign, A$APRocky
		artist="${artist//"$"/"s"}"

		# Convert to lowercase
		title="${title,,}"

		# Remove all white space
		title="${title//[[:space:]]}"

		title="${title//"$"/"s"}"
		fallback_title="${title}"

		# Remove diacritics from strings
		title="$(printf '%s\n' "$title" | iconv -f utf8 -t ascii//TRANSLIT)"

		# Useful for CJK characters
		[[ -z $title || $title == *"???"* ]] && title="${fallback_title}"

		# Sanitize title string
		for sanitize in "(" ")" "[" "]" "-" "!" "?" "=" "&" "#" ":" ";" "'" "*" "+" '“' '”' "‘" "’" "/" "," "feat." "featuring" "ft." "." "explicit" "digitalbonustrack" "bonustrack" "demoversion" "acousticversion" "originalversion"; do
			[[ $sanitize =~ "feat."|"ft."|"featuring" ]] && {
				title="${title//"$sanitize"*}"
			}
			title="${title//"$sanitize"}"
		done

		# Skip if missing tags, useful for CJK characters
		[[ -z $artist || -z $title ]] && {
			missing_lyrics="true"
			skip="true"
			exit_status=1
			return
		}

		artist="${artist//[[:space:]]}"
		title="${title//[[:space:]]}"

		url="https://www.azlyrics.com/lyrics/${artist}/${title}.html"

		output="$(content_loader "$url")"

		# Check for internet connection problems
		[[ -z $output ]] && failed_to_fetch "$@"

		# Check if website gave a valid response
		[[ $output != *"Welcome to AZLyrics"* ]] && [[ $output != *"az_captcha"* || $output != *az_recaptcha* ]] && {
			# Sanitize output string
			output="${output//*"Usage of azlyrics.com"}"
			output="${output//"</div>"*}"
			output="${output//"<br>"}"
			output="${output//*"->"}"
			output="${output//"<i>"}"
			output="${output//"</i>"}"
			output="${output//"&quot;"}"
			output="${output//"&amp;"}"
			output="${output//":]"/"]"}"

			printf '%s\n' "${output}" > "$lrc_file"
			exit_status=0
			return
		}

		# Check for missing lyrics page
		[[ $output == *"Welcome to AZLyrics"* ]] && {
			missing_lyrics="true"
			skip="true"
			exit_status=1
			return
		}

		# Check for rate limit or captcha page
		[[ $output == *"az_captcha"* || $output == *az_recaptcha* ]] && {
			captcha_response="true"
			skip="true"
			exit_status=1
			return
		}

		# Act as a catch all or `else`
		missing_lyrics="true"
		unset failed_fetch
		exit_status=1

		# Add delay between each run to prevent a captcha response
		read -rt "1" <> <(:) || :
	}

	songlyrics_parser() {
		# Create variables with song tags
		fetch_song_tags "$@"

		# Convert to lowercase
		artist="${artist,,}"

		# Replace all whitespace with -
		artist="${artist//[[:space:]]/"-"}"
		artist="${artist//"--"/"-"}"

		# Fix artist naming scheme
		artist="${artist//"'"/"-"}"
		artist="${artist//"‘"/"-"}"
		artist="${artist//"’"/"-"}"
		artist="${artist//'“'/"-"}"
		artist="${artist//'”'/"-"}"

		# Useful for "artists" like Tydolla$ign, A$APRocky
		artist="${artist//"$"/"s"}"
		fallback_artist="${artist}"

		# Remove diacritics from strings
		artist="$(printf '%s\n' "$artist" | iconv -f utf8 -t ascii//TRANSLIT)"

		# Useful for CJK characters
		[[ -z $artist || $artist == *"???"* ]] && artist="${fallback_artist}"

		# Sanitize artist string
		for sanitize in "(" ")" "[" "]" "!" "?" "=" "&" "#" ":" ";" "/" "," "-feat." "-featuring" "-ft." "." "-with"; do
			[[ $sanitize =~ "-feat."|"-ft."|"-featuring"|","|";"|"-with" ]] && {
				artist="${artist//"$sanitize"*}"
			}
			artist="${artist//"$sanitize"}"
		done

		# Convert to lowercase
		title="${title,,}"

		# Replace all whitespace with -
		title="${title//[[:space:]]/"-"}"
		title="${title//"--"/"-"}"

		# Fix title naming scheme
		title="${title//"'"/"-"}"
		title="${title//"‘"/"-"}"
		title="${title//"’"/"-"}"
		title="${title//'“'/"-"}"
		title="${title//'”'/"-"}"

		title="${title//"$"/"s"}"
		fallback_title="${title}"

		# Remove diacritics from strings
		title="$(printf '%s\n' "$title" | iconv -f utf8 -t ascii//TRANSLIT)"

		# Useful for CJK characters
		[[ -z $title || $title == *"???"* ]] && title="${fallback_title}"

		# Sanitize title string
		for sanitize in "(" ")" "[" "]" "!" "?" "=" "&" "#" ":" ";" "*" "/" "," "-feat." "-featuring" "-ft." "." "-explicit" "-digital-bonus-track" "-bonus-track" "-demo-version" "-acoustic-version" "-original-version"; do
			[[ $sanitize =~ "-feat."|"-ft."|"-featuring" ]] && {
				title="${title//"$sanitize"*}"
			}
			title="${title//"$sanitize"}"
		done

		# Skip if missing tags, useful for CJK characters
		[[ -z $artist || -z $title ]] && {
			missing_lyrics="true"
			skip="true"
			exit_status=1
			return
		}

		# Handles double spacing
		artist="${artist//"--"/"-"}"
		artist="${artist//[[:space:]]/"-"}"

		title="${title//"--"/"-"}"
		title="${title//[[:space:]]/"-"}"

		url="https://www.songlyrics.com/${artist}/${title}-lyrics"

		output="$(content_loader "$url")"

		# Check for internet connection problems
		[[ -z $output ]] && failed_to_fetch "$@"

		# Check if website gave a valid response
		[[ $output != *"Missing Album"* ]] && [[ $output != *"We do not have the lyrics for"* ]] && [[ $output != *"Sorry, we have no"* ]] && {
			# Sanitize output string
			output="${output//*"iComment-text\">"}"
			output="${output//"<br /></p>"*}"
			output="${output//"<br />"}"

			# Add secondary check because songlyrics responses are invalid at times
			[[ ${output} == *songlyrics.com* ]] && {
				missing_lyrics="true"
				skip="true"
				exit_status=1
				return
			}

			printf '%s\n' "${output}" > "$lrc_file"
			exit_status=0
			return
		}

		# Check for missing lyrics page
		[[ $output == *"Missing Album"* || $output == *"We do not have the lyrics for"* || $output == *"Sorry, we have no"* ]] && {
			missing_lyrics="true"
			skip="true"
			exit_status=1
			return
		}

		# Act as a catch all or `else`
		missing_lyrics="true"
		unset failed_fetch
		exit_status=1
	}

	check_input_argument() {
		for file_name in "${@:1}"; do
			case "$file_name" in
				*)
					# Check if source file exists
					[[ ! -e $file_name ]] && {
						print_error "Cannot stat '$file_name': No such file or directory"
						printf '\n'
						exit_status=1
					}

					while read -r sec_file_name; do
						[[ -e $sec_file_name ]] && {
							unset exit_status
							unset missing_lyrics
							unset captcha_response
							unset failed_fetch
							unset skip
							unset valid_file

							# Remove file name extension
							lrc_file="${sec_file_name%.*}.lrc"

							parsed_file="$sec_file_name"

							# Check if $sec_file_name contains valid files
							check_audio_files "$@"

							# Only run for audio files
							[[ $valid_file == "true" ]] && {
								# Try lrclib.net first
								lrclib_parser "$sec_file_name"

								# Try www.azlyrics.com if lrclib_parser fails to fetch lyrics
								[[ $failed_fetch == "true" || $captcha_response == "true" || $missing_lyrics == "true" || $exit_status -eq 1 ]] && {
									# Reset variables for new run
									unset exit_status
									unset missing_lyrics
									unset captcha_response
									unset failed_fetch
									unset skip
									azlyrics_parser "$sec_file_name"
								}

								# Try www.songlyrics.com if azlyrics_parser fails to fetch lyrics
								[[ $failed_fetch == "true" || $captcha_response == "true" || $missing_lyrics == "true" || $exit_status -eq 1 ]] && {
									# Reset variables for new run
									unset exit_status
									unset missing_lyrics
									unset captcha_response
									unset failed_fetch
									unset skip
									songlyrics_parser "$sec_file_name"
								}

								# Handles captcha responses
								[[ $captcha_response == "true" ]] && {
									print_error "Captcha response detected"
									print_aligned "Try again later"
									printf '\n'
									exit 1
								}

								# Handles missing lyrics on all parsed websites
								[[ $missing_lyrics == "true" ]] && {
									print_error "No lyrics found for '$parsed_file'"
									exit_status=1
									printf '\n'
								}
 
								[[ $exit_status != 0 && $skip != "true" ]] || [[ $failed_fetch == "true" ]] && {
									print_error "Failed to fetch lyrics for '$sec_file_name'"
									exit_status=1
									printf '\n'
								}
 
								# Print program run status
								[[ -n $exit_status && $exit_status -eq 0 && $skip != "true" ]] && {
									print_success "Added Lyrics file for '$sec_file_name'"
									exit_status=0
									printf '\n'
								}
							}
						}

					# Feed while loop data using here string ----> so exit_status is not empty on subshell exit
					done <<< "$(find "$file_name" 2>/dev/null)"

					# $exit_status will be empty because of a failed file read
					[[ -z ${exit_status} ]] && {
						print_error "Cannot read '$file_name' file: Permission denied"
						printf '\n'
					}

				;;
			esac
		done

		# Exit status for successful run
		exit "${exit_status:=1}"
	}

	trap 'run_on_exit' 1 2 3 15
	print_no_argument "$@"
	input_option_type_one "$@"
	check_dependencies "$@"
	check_input_argument "$@"
	exit
}

#--------------------------------------------------------------
# Platform: Device Agnostic
# Dependencies: mkdir, cp, find
#--------------------------------------------------------------
mkcp() {
	print_help() {
echo -e "\033[1;97mNAME\033[00m
	$SCRIPT_NAME - copy file(s)/folder(s) to the specified folder.

\033[1;97mSYNOPSIS\033[00m
	$SCRIPT_NAME [FOLDER] [FILE(s)...]
	$SCRIPT_NAME [OPTION]

\033[1;97mDESCRIPTION\033[00m
	\033[1;97m$SCRIPT_NAME\033[00m copies the specified [FILE(s)...] into the specified [FOLDER].
	It will create the destination folder if it doesn't already exist.

	\033[1;97m-h, --help\033[00m
		display this help message and exit.

	\033[1;97m-V, --version\033[00m
		output version information and exit.

\033[1;97mAUTHOR\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.
	Written by Kolade Ayomide Olanrewaju.

\033[1;97mREPORTING BUGS\033[00m
	Create a new issue at <https://github.com/teth3r/tether/>.

\033[1;97mCOPYRIGHT\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.

tether $SCRIPT_VERSION"
exit 0
	}

	check_dependencies() {
		# Check for required dependencies
		for mis_dep in mkdir cp find; do
			[[ ! $(type -p "$mis_dep") ]] && {
				print_missing_dependencies "$mis_dep"
			}
		done

		# Declare destination directory
		folder_name="$1"

		# Check if a file exist with $folder_name
		[[ -e $folder_name && ! -d $folder_name ]] && {
			print_error "Cannot create directory '$folder_name': File exists"
			exit 1
		}

		# Check if a file exist with $folder_name
		[[ $# -eq 1 ]] && {
			print_error "Missing source file operand after '$folder_name'"
			print_notification
		}
	}

	check_input_argument() {
		for file_name in "${@:2}"; do
			case "$file_name" in
				*)
					# Check if source file exists
					[[ ! -e $file_name ]] && {
						print_error "Cannot stat '$file_name': No such file or directory"
						exit_status=1
					}

					# Check if source file and destination directory are the same
					[[ $file_name == "$folder_name" ]] && {
						print_error "'$file_name' and '$folder_name' are the same file"
						print_aligned "Aborting"
						exit 1
					}

					# Create destination directory
					mkdir -p "$folder_name" 2>/dev/null || print_write_error "$folder_name"

					# Handles if $file_name is a file but not a directory
					# Handles special files, stuff normally not caught by -f
					[[ -e $file_name && ! -d $file_name ]] && {
						unset exit_status

						# Allow copying symbolic links as-is on filesystems that support it
						cp -rf "$file_name" "$folder_name" 2>/dev/null ||
						cp -f "$file_name" "$folder_name" 2>/dev/null

						exit_status="$?"

						[[ $exit_status -gt 0 ]] && {
							print_error "Cannot create file '${folder_name%\/}/${file_name##*\/}': Permission denied"
						}
					}

					# Work around to allow copying folders containing symlinks to Android
					# Handles if $file_name is a directory
					[[ -d $file_name ]] && {
						# folder_name --> foldername/ -> foldername
						sec_folder_name=${folder_name%\/}

						while read -r sec_file_name; do
							[[ -d $sec_file_name ]] && {
								unset exit_status

								# Gets filename from user prompt and removes the directory path
								# file_name --> /home/username/folder -> folder
								new_file_name=${file_name##*\/}

								[[ -z $new_file_name ]] && {
									# /home/username/folder/*  -> /home/username/folder/
									new_file_name=${file_name%\*}

									# /home/username/folder/  -> /home/username/folder
									new_file_name=${new_file_name%\/}

									# /home/username/folder  -> folder
									new_file_name=${new_file_name##*\/}
								}

								# sec_file_name --> /home/username/folder/folder1/name/ -> /folder1/name/
								sec_file_name="${sec_file_name//*"$new_file_name"}"

								# Creates folder in destination directory using $new_file_name as base directory
								mkdir -p "${sec_folder_name}/${new_file_name}${sec_file_name}" 2>/dev/null && exit_status=0

								[[ -z $exit_status ]] && {
									print_error "Cannot create directory '${sec_folder_name}/${new_file_name}${sec_file_name}': Permission denied"
								}

								# Remove destination folder duplicate --- consequence of using find, first result is the input file path
								dup_file_name="${file_name}"

								# /home/username/file  -> home/username/file
								dup_file_name="${dup_file_name#\/}"

								# home/username/file  -> home
								dup_file_name="${dup_file_name%%\/*}"

								rm -r "${sec_folder_name}/${new_file_name:=?}/${dup_file_name:=?}" 2>/dev/null

								unset exit_status

								# Set exit_status if source folder is empty and is readable
								[[ $(printf '%s\n' "${file_name}/"*) == "${file_name}/*" || $(printf '%s\n' "${file_name}/".*) == "${file_name}/.*" ]] && {
									find "$file_name" &>/dev/null && exit_status=0
								}
							}

							[[ -e $sec_file_name && ! -d $sec_file_name ]] && {
								unset exit_status

								# Gets filename from user prompt and removes the directory path
								# file_name --> /home/username/folder -> folder
								new_file_name=${file_name##*\/}

								[[ -z $new_file_name ]] && {
									# /home/username/file/*  -> home/username/file/
									new_file_name=${file_name%\*}

									# /home/username/file/  -> home/username/file
									new_file_name=${new_file_name%\/}

									# /home/username/file  -> file
									new_file_name=${new_file_name##*\/}
								}

								# Copies file into created destination directory using $new_file_name as base directory
								# sec_file_name --> /home/username/folder/folder1/name -> folder1/name
								# Allow copying symbolic links as-is on filesystems that support it
								cp -rf "$sec_file_name" "${sec_folder_name}/${new_file_name}/${sec_file_name//*"$new_file_name"\/}" 2>/dev/null ||
								cp -f "$sec_file_name" "${sec_folder_name}/${new_file_name}/${sec_file_name//*"$new_file_name"\/}" 2>/dev/null

								exit_status="$?"

							}
						# Feed while loop data using here string ----> so exit_status is not empty on subshell exit
						done <<< "$(find "$file_name" 2>/dev/null)"
					}

					# $exit_status will be empty because of a failed file read
					[[ -z ${exit_status} ]] && {
						print_error "Cannot read '$file_name' file: Permission denied"
					}

					# Print program run status
					[[ -n $exit_status && $exit_status -eq 0 ]] && {
						print_success "Copied '$file_name' to '$folder_name'"
					}
				;;
			esac
		done

		# Handles specified files not existing
		# Alternative to `ls -A "$folder_name"`
		[[ $(printf '%s\n' "$folder_name/"*) == "$folder_name/*" && $(printf '%s\n' "$folder_name/".*) == "$folder_name/.*" ]] && {
			rm -r "$folder_name" 2>/dev/null
			exit 1
		}

		# Exit status for successful run
		exit "${exit_status:=1}"
	}

	trap 'run_on_exit' 1 2 3 15
	print_no_argument "$@"
	input_option_type_one "$@"
	check_dependencies "$@"
	check_input_argument "$@"
	exit
}

#--------------------------------------------------------------
# Platform: Device Agnostic
# Dependencies: mkdir, cp, find, rm
#--------------------------------------------------------------
mkmv() {
	print_help() {
echo -e "\033[1;97mNAME\033[00m
	$SCRIPT_NAME - move file(s)/folder(s) to the specified folder.

\033[1;97mSYNOPSIS\033[00m
	$SCRIPT_NAME [FOLDER] [FILE(s)...]
	$SCRIPT_NAME [OPTION]

\033[1;97mDESCRIPTION\033[00m
	\033[1;97m$SCRIPT_NAME\033[00m moves the specified [FILE(s)...] into the specified [FOLDER].
	It will create the destination folder if it doesn't already exist.

	\033[1;97m-h, --help\033[00m
		display this help message and exit.

	\033[1;97m-V, --version\033[00m
		output version information and exit.

\033[1;97mAUTHOR\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.
	Written by Kolade Ayomide Olanrewaju.

\033[1;97mREPORTING BUGS\033[00m
	Create a new issue at <https://github.com/teth3r/tether/>.

\033[1;97mCOPYRIGHT\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.

tether $SCRIPT_VERSION"
exit 0
	}

	check_dependencies() {
		# Check for required dependencies
		for mis_dep in mkdir cp find; do
			[[ ! $(type -p "$mis_dep") ]] && {
				print_missing_dependencies "$mis_dep"
			}
		done

		# Declare destination directory
		folder_name="$1"

		# Check if a file exist with $folder_name
		[[ -e $folder_name && ! -d $folder_name ]] && {
			print_error "Cannot create directory '$folder_name': File exists"
			exit 1
		}

		# Check if a file exist with $folder_name
		[[ $# -eq 1 ]] && {
			print_error "Missing source file operand after '$folder_name'"
			print_notification
		}
	}

	check_input_argument() {
		for file_name in "${@:2}"; do
			case "$file_name" in
				*)
					# Check if source file exists
					[[ ! -e $file_name ]] && {
						print_error "Cannot stat '$file_name': No such file or directory"
						exit_status=1
					}

					# Check if source file and destination directory are the same
					[[ $file_name == "$folder_name" ]] && {
						print_error "'$file_name' and '$folder_name' are the same file"
						print_aligned "Aborting"
						exit 1
					}

					# Create destination directory
					mkdir -p "$folder_name" 2>/dev/null || print_write_error "$folder_name"

					# Handles if $file_name is a file but not a directory
					# Handles special files, stuff normally not caught by -f
					[[ -e $file_name && ! -d $file_name ]] && {
						unset exit_status

						# Allow copying symbolic links as-is on filesystems that support it
						cp -rf "$file_name" "$folder_name" 2>/dev/null ||
						cp -f "$file_name" "$folder_name" 2>/dev/null

						exit_status="$?"

						[[ $exit_status -gt 0 ]] && {
							print_error "Cannot create file '${folder_name%\/}/${file_name##*\/}': Permission denied"
						}
					}

					# Work around to allow moving folders containing symlinks to Android
					# Handles if $file_name is a directory
					[[ -d $file_name ]] && {
						# folder_name --> foldername/ -> foldername
						sec_folder_name=${folder_name%\/}

						while read -r sec_file_name; do
							[[ -d $sec_file_name ]] && {
								unset exit_status

								# Gets filename from user prompt and removes the directory path
								# file_name --> /home/username/folder -> folder
								new_file_name=${file_name##*\/}

								[[ -z $new_file_name ]] && {
									# /home/username/file/*  -> /home/username/file/
									new_file_name=${file_name%\*}

									# /home/username/file/  -> /home/username/file
									new_file_name=${new_file_name%\/}

									# /home/username/file  -> file
									new_file_name=${new_file_name##*\/}
								}

								# sec_file_name --> /home/username/folder/folder1/name/ -> /folder1/name/
								sec_file_name="${sec_file_name//*"$new_file_name"}"

								# Creates folder in destination directory using $new_file_name as base directory
								mkdir -p "${sec_folder_name}/${new_file_name}${sec_file_name}" 2>/dev/null && exit_status=0

								[[ -z $exit_status ]] && {
									print_error "Cannot create directory '${sec_folder_name}/${new_file_name}${sec_file_name}': Permission denied"
								}

								# Remove destination folder duplicate --- consequence of using find, first result is the input file path
								dup_file_name="${file_name}"

								# /home/username/file  -> home/username/file
								dup_file_name="${dup_file_name#\/}"

								# home/username/file  -> home
								dup_file_name="${dup_file_name%%\/*}"

								rm -r "${sec_folder_name}/${new_file_name:=?}/${dup_file_name:=?}" 2>/dev/null

								unset exit_status

								# Set exit_status if source folder is empty and is readable
								[[ $(printf '%s\n' "${file_name}/"*) == "${file_name}/*" || $(printf '%s\n' "${file_name}/".*) == "${file_name}/.*" ]] && {
									find "$file_name" &>/dev/null && exit_status=0
								}
							}

							[[ -e $sec_file_name && ! -d $sec_file_name ]] && {
								unset exit_status

								# Gets filename from user prompt and removes the directory path
								# file_name --> /home/username/folder -> folder
								new_file_name=${file_name##*\/}

								[[ -z $new_file_name ]] && {
									# /home/username/file/*  -> home/username/file/
									new_file_name=${file_name%\*}

									# /home/username/file/  -> home/username/file
									new_file_name=${new_file_name%\/}

									# /home/username/file  -> file
									new_file_name=${new_file_name##*\/}
								}

								# Copies file into created destination directory using $new_file_name as base directory
								# sec_file_name --> /home/username/folder/folder1/name -> folder1/name
								# Allow copying symbolic links as-is on filesystems that support it
								cp -rf "$sec_file_name" "${sec_folder_name}/${new_file_name}/${sec_file_name//*"$new_file_name"\/}" 2>/dev/null ||
								cp -f "$sec_file_name" "${sec_folder_name}/${new_file_name}/${sec_file_name//*"$new_file_name"\/}" 2>/dev/null

								exit_status="$?"

							}
						# Feed while loop data using here string ----> so exit_status is not empty on subshell exit
						done <<< "$(find "$file_name" 2>/dev/null)"
					}

					# $exit_status will be empty because of a failed file read
					[[ -z ${exit_status} ]] && {
						print_error "Cannot read '$file_name' file: Permission denied"
					}

					# Print program run status
					[[ -n $exit_status && $exit_status -eq 0 ]] && {
						print_success "Moved '$file_name' to '$folder_name'"
						# Delete copied file
						rm -rf "$file_name" 2>/dev/null
					}
				;;
			esac
		done

		# Handles specified files not existing
		# Alternative to `ls -A "$folder_name"`
		[[ $(printf '%s\n' "$folder_name/"*) == "$folder_name/*" && $(printf '%s\n' "$folder_name/".*) == "$folder_name/.*" ]] && {
			rm -r "$folder_name" 2>/dev/null
			exit 1
		}

		# Exit status for successful run
		exit "${exit_status:=1}"
	}

	trap 'run_on_exit' 1 2 3 15
	print_no_argument "$@"
	input_option_type_one "$@"
	check_dependencies "$@"
	check_input_argument "$@"
	exit
}

#--------------------------------------------------------------
# Platform: Device Agnostic
# Dependencies: mkdir, touch
#--------------------------------------------------------------
mktouch() {
	print_help() {
echo -e "\033[1;97mNAME\033[00m
	$SCRIPT_NAME - create empty file(s) in the specified folder.

\033[1;97mSYNOPSIS\033[00m
	$SCRIPT_NAME [FOLDER] [FILE(s)...]
	$SCRIPT_NAME [OPTION]

\033[1;97mDESCRIPTION\033[00m
	\033[1;97m$SCRIPT_NAME\033[00m creates empty [FILE(s)...] in the specified [FOLDER].
	It will create the destination folder if it doesn't already exist.

	\033[1;97m-h, --help\033[00m
		display this help message and exit.

	\033[1;97m-V, --version\033[00m
		output version information and exit.

\033[1;97mAUTHOR\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.
	Written by Kolade Ayomide Olanrewaju.

\033[1;97mREPORTING BUGS\033[00m
	Create a new issue at <https://github.com/teth3r/tether/>.

\033[1;97mCOPYRIGHT\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.

tether $SCRIPT_VERSION"
exit 0
	}

	check_dependencies() {
		# Check for required dependencies
		for mis_dep in mkdir touch; do
			[[ ! $(type -p "$mis_dep") ]] && {
				print_missing_dependencies "$mis_dep"
			}
		done

		# Declare destination directory
		folder_name="$1"

		# Check if a file exist with $folder_name
		[[ -e $folder_name && ! -d $folder_name ]] && {
			print_error "Cannot create directory '$folder_name': File exists"
			exit 1
		}

		# Check if $file_name is not provided
		[[ $# -eq 1 ]] && {
			print_error "Missing source file operand after '$folder_name'"
			print_notification
		}
	}

	failed_to_create() {
		print_error "Failed to create '$file_name' in '$folder_name'"
		exit_status=1
	}

	check_input_argument() {
		for file_name in "${@:2}"; do
			unset exit_status
			case "$file_name" in
				*)
					# Check if a file exist with $file_name
					[[ -e "${folder_name}/${file_name}" ]] && {
						print_error "Cannot create file '$file_name': File exists"
						print_aligned "Aborting"
						exit 1
					}

					# Create destination directory
					mkdir -p "$folder_name" 2>/dev/null || print_write_error "$folder_name"

					printf 2>/dev/null '\n' > "${folder_name}"/"${file_name:=?}"

					exit_status="$?"

					[[ -n $exit_status && $exit_status -eq 0 ]] && {
						print_success "Created '$file_name' in '$folder_name'"
					}

					[[ $exit_status -gt 0 ]] && {
						failed_to_create "$@"
					}
				;;
			esac
		done

		# Handles specified files not existing
		# Alternative to `ls -A "$folder_name"`
		[[ $(printf '%s\n' "$folder_name/"*) == "$folder_name/*" && $(printf '%s\n' "$folder_name/".*) == "$folder_name/.*" ]] && {
			rm -r "$folder_name" 2>/dev/null
			exit 1
		}

		# Exit status for successful run
		exit "${exit_status:=1}"
	}

	trap 'run_on_exit' 1 2 3 15
	print_no_argument "$@"
	input_option_type_one "$@"
	check_dependencies "$@"
	check_input_argument "$@"
	exit
}

#--------------------------------------------------------------
# Platform: Android
# Dependencies: cp, mkdir, pm
#--------------------------------------------------------------
omaps-backup() {
	print_help() {
echo -e "\033[1;97mNAME\033[00m
	$SCRIPT_NAME - create and restore organic maps backups.

\033[1;97mSYNOPSIS\033[00m
	$SCRIPT_NAME [OPTION]

\033[1;97mDESCRIPTION\033[00m
	\033[1;97m$SCRIPT_NAME\033[00m creates or restores backups of organic maps
	mwm files. It saves and restores the backups from external storage
	and will only fallback to using Android's internal storage if no
	external storage device exists.

	\033[1;97m-b, --backup\033[00m
		create a backup of organic maps.

	\033[1;97m-h, --help\033[00m
		display this help message and exit.

	\033[1;97m-l, --list\033[00m
		list available backup(s).

	\033[1;97m-r, --restore\033[00m
		restore organic maps from available backup(s).

	\033[1;97m-V, --version\033[00m
		output version information and exit.

\033[1;97mAUTHOR\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.
	Written by Kolade Ayomide Olanrewaju.

\033[1;97mREPORTING BUGS\033[00m
	Create a new issue at <https://github.com/teth3r/tether/>.

\033[1;97mCOPYRIGHT\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.

tether $SCRIPT_VERSION"
exit 0
	}

	check_dependencies() {
		# Only run on Android
		[[ ! -d /system/app/ || ! -f /system/build.prop ]] && {
			print_os_error
		}

		# Check for required dependencies
		for mis_dep in cp mkdir pm; do
			[[ ! $(type -p "$mis_dep") ]] && {
				print_missing_dependencies "$mis_dep"
			}
		done

		# Only run as root
		# Non root user cannot access /sdcard/Android/data/
		print_not_root_user

		# Handles no organic maps install
		[[ ! $(pm list packages "app.organicmaps" 2>/dev/null) ]] && {
			print_error "Organic Maps is not installed"
			print_notification
			exit 1
		}

		# Set organic maps content directories
		omaps_internal="$PHONE_STORAGE/Android/data/app.organicmaps"
		[[ -n $EXTERNAL_STORAGE ]] && {
			omaps_external="$EXTERNAL_STORAGE/Android/data/app.organicmaps"
		}

		# Array of content directories
		omaps_backup_candidates=(
			"$omaps_internal"
			"$omaps_external"
		)

		# Handles missing organic maps folders
		unset backup_checker

		backup_checker=0
		for avail_dir in "${omaps_backup_candidates[@]}"; do
			[[ -d $avail_dir ]] && {
				backup_checker=$((backup_checker + 1))
			}
		done

		# Set organic maps backup directory
		omaps_backup_dir="$PHONE_STORAGE/Misc/omaps-backup"

		# Use external storage if available
		[[ -d "$EXTERNAL_STORAGE" ]] && {
			omaps_backup_dir="$EXTERNAL_STORAGE/Misc/omaps-backup"
		}

		# Get date and time in YYYY.MM.DD.HH.MM format
		current_date="$(printf '%(%Y.%m.%d.%H%M)T\n')"
	}

	failed_to_create() {
		print_error "Something went wrong"
		print_aligned "Failed to create 'omaps-backup/omaps-backup.${current_date}'"
		rm -rf "${omaps_backup_dir}/omaps-backup.${current_date:=?}" 2>/dev/null
		exit 1
	}

	failed_to_restore() {
		printf '\n'
		print_error "Failed to restore '${backup_list[$backup_option]}'"
		exit 1
	}

	backup_omaps() {
		print_warning "Creating organic maps backup 'omaps-backup.${current_date}'"
		printf '\n'

		unset avail_dir

		# Create backups of each omaps content folder
		for avail_dir in "${omaps_backup_candidates[@]}"; do
			[[ -d $avail_dir ]] && {
				file_name="${avail_dir#\/}"
				file_name="${file_name%%\/*}"
				# Copy $avail_dir contents
				mkdir -p "${omaps_backup_dir}/omaps-backup.${current_date}/${file_name}" 2>/dev/null || print_write_error "${omaps_backup_dir}/omaps-backup.${current_date}"
				cp -rf "${avail_dir}/files" "${omaps_backup_dir}/omaps-backup.${current_date}/${file_name}" 2>/dev/null ||
				failed_to_create "$@"
			}
		done

		print_success "Finished creating 'omaps-backup.${current_date}'"
		print_aligned "Check '$omaps_backup_dir'"

		exit 0
	}

	restore_omaps() {
		# Set variables for available backups
		array_counter=1

		for avail_backup in "$omaps_backup_dir"/*; do
			[[ -e $avail_backup ]] && {
				backup_list[array_counter]="${avail_backup//*\/}"
				array_counter=$((array_counter + 1))
			}
		done

		# Handles no available backups
		[[ $array_counter -eq 1 ]] && {
			print_error "No available backups to restore from"
			exit 1
		}

		# List available backups
		print_banner
		print_warning "Restoring organic maps"
		printf '\n'
		for ((array_checker=1; array_checker < array_counter; array_checker++)); do
			printf '%s.%s\n' "${array_checker}" "${backup_list[$array_checker]}"
		done
		printf '\n'
		read -rep "Select preferred backup: " backup_option
		case "$backup_option" in
			-*)
				printf '\n'
				[[ -z ${backup_option#*\-} ]] && {
					print_error "Unrecognized option '${backup_option}'" &&
					exit 1
				}

				print_error "Invalid option -- '${backup_option#*\-}'" &&
				exit 1
			;;
			*)
				printf '\n'
				[[ $(( backup_option / 1 )) -gt 0 && $backup_option -lt $array_counter ]] && {
					print_warning "Restoring organic maps using '${backup_list[$backup_option]}'"

					for avail_dir in "${omaps_backup_candidates[@]}"; do
						file_name="${avail_dir#\/}"
						file_name="${file_name%%\/*}"
						[[ -d ${omaps_backup_dir}/${backup_list[$backup_option]}/${file_name} ]] && {
							# Copy backup folder contents
							mkdir -p "${avail_dir}" 2>/dev/null || print_write_error "${avail_dir}"
							cp -rf "${omaps_backup_dir}/${backup_list[$backup_option]}/${file_name}/files" "${avail_dir}" 2>/dev/null ||
							failed_to_restore "$@"
						}
					done

					printf '\n' &&
					print_success "Finished restoring '${backup_list[$backup_option]}'"

					exit 0
				}

				print_error "Unrecognized option '${backup_option}'" &&
				exit 1
			;;
		esac
	}

	check_input_option() {
		for primary_options in "${@:1}"; do
			case "$primary_options" in
				-b | --backup)
					check_dependencies "$@"

					# Handles if $omaps_backup exists and is empty
					[[ $(printf '%s\n' "$omaps_internal/"*) == "$omaps_internal/*" || ! -d $omaps_internal || $backup_checker -eq 0 ]] && {
						print_error "There is nothing to backup"
						print_aligned "Try running 'Organic Maps' at least once"
						exit 1
					}

					backup_omaps "$@"
				;;
				-h | --help)
					print_help
				;;
				-l | --list)
					check_dependencies "$@"

					# Handles no available omaps backup
					[[ $(printf '%s\n' "$omaps_backup_dir/"*) == "$omaps_backup_dir/*" ]] && {
						print_error "No available backups"
						exit 1
					}

					printf '\033[1;97mAvailable backups:\033[00m\n'

					backup_content="$(printf '%s\n' "$omaps_backup_dir/"*)"
					printf '%s\n' "${backup_content//"${omaps_backup_dir}/"}"
					exit 0
				;;
				-r | --restore)
					check_dependencies "$@"
					restore_omaps "$@"
				;;
				-V | --version)
					print_version
				;;
				-*)
					[[ -z ${primary_options#*\-} || -z ${primary_options/\-\-*} ]] && {
						print_error "Unrecognized option '${primary_options}'"
						print_notification
					}

					print_error "Invalid option -- '${primary_options#*\-}'"
					print_notification
				;;
				*)
					for secondary_options in "${@:2}"; do
						case "$secondary_options" in
							-h | --help)
								print_help
							;;
						esac
					done
					print_syntax_error
				;;
			esac
		done
	}

	trap 'remove_file_on_exit "${omaps_backup_dir}/omaps-backup.${current_date:=?}"' 1 2 3 15
	print_no_argument "$@"
	check_input_option "$@"
	exit
}

#--------------------------------------------------------------
# Platform: Android
# Dependencies: ping, magisk, sed
#--------------------------------------------------------------
package() {
	print_help() {
echo -e "\033[1;97mNAME\033[00m
	$SCRIPT_NAME - magisk module packaging tool.

\033[1;97mSYNOPSIS\033[00m
	$SCRIPT_NAME [OPTION]

\033[1;97mDESCRIPTION\033[00m
	\033[1;97m$SCRIPT_NAME\033[00m creates a custom magisk module that incorporates different
	CLI tools and modifications to improve user experience on Android.
	It saves the created module on external storage and will only fallback
	to using Android's internal storage if no external storage device exists.

	\033[1;97m-h, --help\033[00m
		display this help message and exit.

	\033[1;97m-V, --version\033[00m
		output version information and exit.

\033[1;97mAUTHOR\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.
	Written by Kolade Ayomide Olanrewaju.

\033[1;97mREPORTING BUGS\033[00m
	Create a new issue at <https://github.com/teth3r/tether/>.

\033[1;97mCOPYRIGHT\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.

tether $SCRIPT_VERSION"
exit 0
	}

	check_dependencies() {
		# Only run on Android
		[[ ! -d /system/app ]] && print_os_error

		# Run only on arm64 Android
		[[ $HOSTTYPE != aarch64 ]] && print_os_error

		# Run only as root user
		print_not_root_user

		# Check for required dependencies
		for mis_dep in mkdir ping sed rm; do
			[[ ! $(type -p "$mis_dep") ]] && {
				print_missing_dependencies "$mis_dep"
			}
		done

		# Check for internet connectivity
		[[ ! $(ping -c4 voidlinux.org 2>/dev/null) ]] && {
			print_error "Failed to detect an internet connection"
			exit 1
		}

		# Only run if magisk is installed
		[[ ! $(type -p magisk) ]] && [[ ! $(type -p su) ]] && {
			print_error "Magisk is not installed"
			exit 1
		}

		package_tmp_dir="/data/local/tmp/package"
		tmp_dir="/data/local/tmp"

		# Remove directory incase it already exists
		rm -r "$package_tmp_dir" 2>/dev/null
		rm -r "$tmp_dir/tether" 2>/dev/null

		# Dnscrypt version
		dnscrypt_version="2.1.5"

		# 7zip version
		z_version="2301"

		# Get current directory
		current_dir="$PWD"

		# Get date and time in YYYY.MM.DD.HH.MM format
		current_date="$(printf '%(%Y.%m.%d.%H%M)T\n')"

		# Declare module backup directory
		backup_dir="$EXTERNAL_STORAGE/Misc/module-backup"

		# Create module package directories
		mkdir -p "$package_tmp_dir/system/app" 2>/dev/null || print_write_error "$package_tmp_dir/system/app"
		mkdir -p "$package_tmp_dir/system/bin" 2>/dev/null || print_write_error "$package_tmp_dir/system/bin"
		mkdir -p "$package_tmp_dir/system/etc" 2>/dev/null || print_write_error "$package_tmp_dir/system/etc"
		mkdir -p "$package_tmp_dir/system/product" 2>/dev/null || print_write_error "$package_tmp_dir/system/product"

		# Copy magisk busybox if not found in PATH
		[[ ! $(type -p "busybox") ]] && {
			cp -f /data/adb/magisk/busybox "$package_tmp_dir/system/bin" 2>/dev/null || print_file_write_error "$package_tmp_dir/system/bin/busybox"
			chmod +x "$package_tmp_dir/system/bin/busybox"
			export PATH=$package_tmp_dir/system/bin:$PATH
		}

		# Copy busybox to package_tmp_dir if it is in PATH
		[[ -f /bin/busybox ]] && {
			cp -f /bin/busybox "$package_tmp_dir/system/bin" || print_file_write_error "$package_tmp_dir/system/bin/busybox"
		}
	}

	download_fail() {
		print_error "Something went wrong"
		print_aligned "Failed to download '$*'"
		rm -r "${package_tmp_dir}" 2>/dev/null
		cd "$current_dir" 2>/dev/null || print_dir_change_error "${current_dir}"
		exit 1
	}

	failed_to_create() {
		print_error "Something went wrong"
		print_aligned "Failed to create 'tether.$current_date.zip'"
		rm -r "${package_tmp_dir}" "$tmp_dir/tether" 2>/dev/null
		cd "$current_dir" 2>/dev/null || print_dir_change_error "${current_dir}"
		exit 1
	}

	download_dnscrypt() {
		mkdir -p "$package_tmp_dir/system/etc/dnscrypt-proxy" 2>/dev/null || print_write_error "$package_tmp_dir/system/etc/dnscrypt-proxy"
		cd "$package_tmp_dir" 2>/dev/null || print_dir_change_error "$package_tmp_dir"
		print_warning "Downloading 'dnscrypt-proxy version $dnscrypt_version'"
		printf '\n'

		# Download dnscrypt-proxy for arm64 Android
		download_link="https://github.com/DNSCrypt/dnscrypt-proxy/releases/download/${dnscrypt_version}/dnscrypt-proxy-android_arm64-${dnscrypt_version}.zip"
		output_path="$package_tmp_dir/dnscrypt-proxy-android_arm64-${dnscrypt_version}.zip"

		busybox wget "$download_link" -O "$output_path" &>/dev/null ||
		download_fail "dnscrypt-proxy-android_arm64-${dnscrypt_version}.zip"

		# Extract downloaded zip file
		busybox unzip "dnscrypt-proxy-android_arm64-${dnscrypt_version}.zip" &>/dev/null

		cp -rf "$package_tmp_dir/android-arm64/dnscrypt-proxy" "$package_tmp_dir/system/bin/" 2>/dev/null || print_file_write_error "$package_tmp_dir/system/bin/dnscrypt-proxy"
		rm -r "$package_tmp_dir/dnscrypt-proxy-android_arm64-${dnscrypt_version}.zip" "$package_tmp_dir/android-arm64" 2>/dev/null

		# Download custom config files for dnscrypt-proxy
		print_warning "Downloading 'dnscrypt-proxy' config files"
		printf '\n'
		busybox wget https://github.com/teth3r/blocklist/archive/refs/heads/main.zip -O "$package_tmp_dir/main.zip" &>/dev/null ||
		download_fail "main.zip"

		# Extract downloaded zip file
		busybox unzip "main.zip" &>/dev/null
		cp -rf "$package_tmp_dir/blocklist-main"/*.txt "$package_tmp_dir/system/etc/dnscrypt-proxy" 2>/dev/null
		cp -rf "$package_tmp_dir/blocklist-main"/*.toml "$package_tmp_dir/system/etc/dnscrypt-proxy" 2>/dev/null

		# Change default DNS port -- Port 53 is used by dnsmasq for mobile hotspot
		sed -i 's|127.0.0.1:53|127.0.0.1:5354|g' "$package_tmp_dir/system/etc/dnscrypt-proxy/dnscrypt-proxy.toml" 2>/dev/null

		# Force TCP usage for connecting to upstream resolvers 
		sed -i 's/force_tcp\ =\ false/force_tcp\ =\ true/' "$package_tmp_dir/system/etc/dnscrypt-proxy/dnscrypt-proxy.toml" 2>/dev/null
		rm -r "$package_tmp_dir/main.zip" "$package_tmp_dir/blocklist-main" 2>/dev/null
	}

	download_bash() {
		print_warning "Downloading 'bash' static binary (ccbins)"
		printf '\n'

		# Download bash static binary from ccbins magisk module repo
		busybox wget https://github.com/Zackptg5/Cross-Compiled-Binaries-Android/raw/master/bash/bash-arm64 -O "$package_tmp_dir/bash-arm64" &>/dev/null ||
		download_fail "bash-arm64"
		cp -rf "$package_tmp_dir/bash-arm64" "$package_tmp_dir/system/bin/bash" 2>/dev/null || print_file_write_error "$package_tmp_dir/system/bin/bash"
		rm -rf "$package_tmp_dir/bash-arm64" 2>/dev/null

		# Add custom mkshrc file
		mkdir -p "$package_tmp_dir/system/etc" 2>/dev/null || print_write_error "$package_tmp_dir/system/etc"
		mksh_file="$package_tmp_dir/system/etc/mkshrc"
		busybox wget "https://github.com/teth3r/dotfiles/raw/master/mkshrc" -O "$mksh_file" &>/dev/null ||
		download_fail "mkshrc"

		# Add custom bashrc file
		mkdir -p "$package_tmp_dir/system/etc/bash" 2>/dev/null || print_write_error "$package_tmp_dir/system/etc/bash"
		bash_file="$package_tmp_dir/system/etc/bash/.bashrc"
		busybox wget "https://github.com/teth3r/dotfiles/raw/master/bashrc" -O "$bash_file" &>/dev/null ||
		download_fail "bashrc"
	}

	download_zip() {
		print_warning "Downloading '7zip' static binary"
		printf '\n'

		mkdir -p "$package_tmp_dir/new" 2>/dev/null

		# Download 7zip for arm64 Android
		busybox wget "https://7-zip.org/a/7z${z_version}-linux-arm64.tar.xz" -O "$package_tmp_dir/new/7z${z_version}-linux-arm64.tar.xz" &>/dev/null ||
		download_fail "7z${z_version}-linux-arm64.tar.xz"

		cd "${package_tmp_dir}/new" 2>/dev/null || print_dir_change_error "${package_tmp_dir}/new"

		# Extract downloaded archive
		busybox xz -d "7z${z_version}-linux-arm64.tar.xz" &>/dev/null
		busybox tar -xf "7z${z_version}-linux-arm64.tar" &>/dev/null

		cp -rf "$package_tmp_dir/new/7zzs" "$package_tmp_dir/system/bin/7z" 2>/dev/null || print_file_write_error "$package_tmp_dir/system/bin/7z"
		cd "$package_tmp_dir/system/bin" 2>/dev/null || print_dir_change_error "${package_tmp_dir}/system/bin"
		ln -sf 7z 7zip 2>/dev/null
		cd "$package_tmp_dir" 2>/dev/null || print_dir_change_error "${package_tmp_dir}"
		rm -r "$package_tmp_dir/new" 2>/dev/null
	}

	download_tether() {
		cd "$package_tmp_dir" 2>/dev/null || print_dir_change_error "${package_tmp_dir}"

		print_warning "Downloading 'tether'"
		printf '\n'

		# Download latest version of tether
		busybox wget "https://raw.githubusercontent.com/teth3r/tether/master/tether" -O "$package_tmp_dir/tether" &>/dev/null ||
		download_fail "tether"

		chmod +x "$package_tmp_dir/tether"
		./tether --silent "$package_tmp_dir/system/bin"
		rm "$package_tmp_dir/tether" 2>/dev/null
	}

	download_custom_iosevka() {
		[[ $font_variant == "sans" ]] && {
			print_warning "Downloading 'Iosevka"
			printf '\n'

			# Download latest version of Iosevka custom build
			busybox wget "https://github.com/teth3r/Iosevka-build/releases/latest/download/Iosevka.7z" -O "$package_tmp_dir/system/bin/Iosevka.7z" &>/dev/null ||
			download_fail "Iosevka"

			mkdir -p "$package_tmp_dir/system/fonts" 2>/dev/null || print_write_error "$package_tmp_dir/system/fonts"
			cd "$package_tmp_dir/system/bin" 2>/dev/null || print_dir_change_error "${package_tmp_dir}/system/bin"
			7z x "$package_tmp_dir/system/bin/Iosevka.7z" &>/dev/null
		}

		[[ $font_variant == "slab" ]] && {
			print_warning "Downloading 'Iosevka-Slab"
			printf '\n'

			# Download latest version of Iosevka custom build
			busybox wget "https://github.com/teth3r/Iosevka-build/releases/latest/download/Iosevka-slab.7z" -O "$package_tmp_dir/system/bin/Iosevka-slab.7z" &>/dev/null ||
			download_fail "Iosevka-Slab"

			mkdir -p "$package_tmp_dir/system/fonts" 2>/dev/null || print_write_error "$package_tmp_dir/system/fonts"
			cd "$package_tmp_dir/system/bin" 2>/dev/null || print_dir_change_error "${package_tmp_dir}/system/bin"
			7z x "$package_tmp_dir/system/bin/Iosevka-slab.7z" &>/dev/null
		}

		# Populate font directory
		cp Iosevka-Regular.ttf "$package_tmp_dir/system/fonts/NotoSerif-Regular.ttf" 2>/dev/null || print_file_write_error "$package_tmp_dir/system/fonts/NotoSerif-Regular.ttf"
		cp Iosevka-Bold.ttf "$package_tmp_dir/system/fonts/NotoSerif-Bold.ttf" 2>/dev/null || print_file_write_error "$package_tmp_dir/system/fonts/NotoSerif-Bold.ttf"
		cp Iosevka-BoldItalic.ttf "$package_tmp_dir/system/fonts/NotoSerif-BoldItalic.ttf" 2>/dev/null || print_file_write_error "$package_tmp_dir/system/fonts/NotoSerif-BoldItalic.ttf"
		cp Iosevka-Italic.ttf "$package_tmp_dir/system/fonts/NotoSerif-Italic.ttf" 2>/dev/null || print_file_write_error "$package_tmp_dir/system/fonts/NotoSerif-Italic.ttf"

		rm "$package_tmp_dir"/system/bin/*.md "$package_tmp_dir"/system/bin/Iosevka* 2>/dev/null

		# Create font symbolic-links
		cd "$package_tmp_dir/system/fonts" 2>/dev/null || print_dir_change_error "${package_tmp_dir}/system/fonts"

		# SourceSansPro
		ln -sf NotoSerif-Regular.ttf SourceSansPro-Regular.ttf 2>/dev/null
		ln -sf NotoSerif-Bold.ttf SourceSansPro-Bold.ttf 2>/dev/null
		ln -sf NotoSerif-BoldItalic.ttf SourceSansPro-BoldItalic.ttf 2>/dev/null
		ln -sf NotoSerif-Italic.ttf SourceSansPro-Italic.ttf 2>/dev/null

		# DroidSans
		ln -sf NotoSerif-Regular.ttf DroidSans.ttf 2>/dev/null
		ln -sf NotoSerif-Regular.ttf DroidSansMono.ttf 2>/dev/null
		ln -sf NotoSerif-Bold.ttf DroidSans-Bold.ttf 2>/dev/null

		cd "$package_tmp_dir" 2>/dev/null || print_dir_change_error "${package_tmp_dir}"
	}

	populate_dir() {
		print_warning "Populating module directories"
		printf '\n'

		# Populate app/
		mkdir -p "$package_tmp_dir/system/app/Stk" 2>/dev/null || print_write_error "$package_tmp_dir/system/app/Stk"
		touch "$package_tmp_dir/system/app/Stk/Stk.apk" 2>/dev/null
	}

	create_module_prop() {
		print_warning "Creating 'module.prop'"
		printf '\n'

		cat 2>/dev/null << "EOF" > "$package_tmp_dir/module.prop"
id=tether
name=tether
version=
versionCode=1
author=tether
description=
EOF
	}

	create_customize() {
		print_warning "Creating 'customize.sh'"
		printf '\n'

		cat 2>/dev/null << "EOF" > "$package_tmp_dir/customize.sh"
#!/bin/env sh

ui_print "
████████╗███████╗████████╗██╗   ██╗███████╗██████═╗
╚══██╔══╝██╔════╝╚══██╔══╝██║   ██║██╔════╝██╔═══██
   ██║   ███████╗   ██║   ████████║███████╗███████═╗
   ██║   ██╔════╝   ██║   ██╔═══██║██╔════╝██╔═══██║
   ██║   ███████╗   ██║   ██║   ██║███████╗██║   ██║
   ╚═╝   ╚══════╝   ╚═╝   ╚═╝   ╚═╝╚══════╝╚═╝   ╚═╝
"
ui_print "Installing $(cat $TMPDIR/module.prop | grep name= | sed 's/name=//') $(cat $TMPDIR/module.prop | grep version= | sed 's/version=//')"
ui_print " "
ui_print "Copyright (C) 2023, Kolade Ayomide Olanrewaju (tether)"
ui_print " "
ui_print "GPL-3.0-or-later"
ui_print " "
EOF
	}

	create_post_fs() {
		print_warning "Creating 'post-fs-data.sh'"
		printf '\n'

		cat 2>/dev/null << "EOF" > "$package_tmp_dir/post-fs-data.sh"
#!/bin/env sh

#--------------------------------------------------------------
# Get module directory
#--------------------------------------------------------------
MODDIR=${0%/*}

#--------------------------------------------------------------
# Copy font.xml file
#--------------------------------------------------------------
cp /system/etc/fonts.xml "$MODDIR/system/etc/"

#--------------------------------------------------------------
# Edit font.xml file to include custom ttf files
#--------------------------------------------------------------
[[ -f "$MODDIR/system/fonts/NotoSerif-Regular.ttf" ]] && {
	sed -i 's/<font weight="100" style="normal">Roboto-Regular.ttf/<font weight="100" style="normal">NotoSerif-Regular.ttf/g' "$MODDIR/system/etc/fonts.xml"
	sed -i 's/<font weight="200" style="normal">Roboto-Regular.ttf/<font weight="200" style="normal">NotoSerif-Regular.ttf/g' "$MODDIR/system/etc/fonts.xml"
	sed -i 's/<font weight="300" style="normal">Roboto-Regular.ttf/<font weight="300" style="normal">NotoSerif-Regular.ttf/g' "$MODDIR/system/etc/fonts.xml"
	sed -i 's/<font weight="400" style="normal">Roboto-Regular.ttf/<font weight="400" style="normal">NotoSerif-Regular.ttf/g' "$MODDIR/system/etc/fonts.xml"
}

[[ -f "$MODDIR/system/fonts/NotoSerif-Italic.ttf" ]] && {
	sed -i 's/<font weight="100" style="italic">Roboto-Regular.ttf/<font weight="100" style="italic">NotoSerif-Italic.ttf/g' "$MODDIR/system/etc/fonts.xml"
	sed -i 's/<font weight="200" style="italic">Roboto-Regular.ttf/<font weight="200" style="italic">NotoSerif-Italic.ttf/g' "$MODDIR/system/etc/fonts.xml"
	sed -i 's/<font weight="300" style="italic">Roboto-Regular.ttf/<font weight="300" style="italic">NotoSerif-Italic.ttf/g' "$MODDIR/system/etc/fonts.xml"
	sed -i 's/<font weight="400" style="italic">Roboto-Regular.ttf/<font weight="400" style="italic">NotoSerif-Italic.ttf/g' "$MODDIR/system/etc/fonts.xml"
}

[[ -f "$MODDIR/system/fonts/NotoSerif-BoldItalic.ttf" ]] && {
	sed -i 's/<font weight="500" style="italic">Roboto-Regular.ttf/<font weight="500" style="italic">NotoSerif-BoldItalic.ttf/g' "$MODDIR/system/etc/fonts.xml"
	sed -i 's/<font weight="600" style="italic">Roboto-Regular.ttf/<font weight="600" style="italic">NotoSerif-BoldItalic.ttf/g' "$MODDIR/system/etc/fonts.xml"
	sed -i 's/<font weight="700" style="italic">Roboto-Regular.ttf/<font weight="700" style="italic">NotoSerif-BoldItalic.ttf/g' "$MODDIR/system/etc/fonts.xml"
	sed -i 's/<font weight="800" style="italic">Roboto-Regular.ttf/<font weight="800" style="italic">NotoSerif-BoldItalic.ttf/g' "$MODDIR/system/etc/fonts.xml"
	sed -i 's/<font weight="900" style="italic">Roboto-Regular.ttf/<font weight="900" style="italic">NotoSerif-BoldItalic.ttf/g' "$MODDIR/system/etc/fonts.xml"
}

[[ -f "$MODDIR/system/fonts/NotoSerif-Bold.ttf" ]] && {
	sed -i 's/Roboto-Regular.ttf/NotoSerif-Bold.ttf/g' "$MODDIR/system/etc/fonts.xml"
}

exit 0
EOF
	}

	create_service() {
		print_warning "Creating 'service.sh'"
		printf '\n'

		cat 2>/dev/null << "EOF" > "$package_tmp_dir/service.sh"
#!/bin/env bash

#--------------------------------------------------------------
# Get module directory
#--------------------------------------------------------------
MODDIR=${0%/*}

#--------------------------------------------------------------
# Enable and configure dnscrypt-proxy
#--------------------------------------------------------------
[[ -f /system/bin/dnscrypt-proxy && -f /system/etc/dnscrypt-proxy/dnscrypt-proxy.toml ]] && {
	# Change IPv4 DNS settings to prevent leakage
	iptables -t nat -A OUTPUT -p tcp ! -d 45.11.45.11 --dport 53 -j DNAT --to-destination 127.0.0.1:5354
	iptables -t nat -A OUTPUT -p udp ! -d 45.11.45.11 --dport 53 -j DNAT --to-destination 127.0.0.1:5354

	# DNScrypt-proxy service manager
	dnscrypt_loader() {
		# Only run if dnscrypt-proxy is not running
		while [[ ! $(pgrep -x dnscrypt-proxy) ]]; do
			dnscrypt-proxy -config "$MODDIR/system/etc/dnscrypt-proxy/dnscrypt-proxy.toml"
			# Add delay so multiple instances are not created
			read -rt "2" <> <(:) || :
		done
	}
	dnscrypt_loader &
}

#--------------------------------------------------------------
# Check for boot_complete trigger
#--------------------------------------------------------------
while [[ $(getprop sys.boot_completed 2>/dev/null) -ne 1 ]]; do
	# Delay to prevent excessive CPU usage on startup
	read -rt "5" <> <(:) || :
done

#--------------------------------------------------------------
# Check if /data partition is decrypted
#--------------------------------------------------------------
test_file="/data/data/PERMISSION_TEST"

while [[ ! -f $test_file ]]; do
	# Delay to prevent excessive CPU usage on startup
	read -rt "7" <> <(:) || :
	# Create test_file file
	touch "$test_file" 2>/dev/null
done

# User has unlocked device, delete test_file
rm -f "$test_file" 2>/dev/null

#--------------------------------------------------------------
# Change hostname to device model -- instead of 'localhost'
#--------------------------------------------------------------
hostname "$(getprop ro.product.vendor.name)"

#--------------------------------------------------------------
# Set CPU clockspeed to max
#--------------------------------------------------------------
for core_group in /sys/devices/system/cpu/cpufreq/*/scaling_governor; do
	printf '%s\n' "performance" > "$core_group"
done

#--------------------------------------------------------------
# Set GPU clockspeed to max
#--------------------------------------------------------------
[[ -d /sys/class/kgsl/kgsl-3d0 ]] && {
	printf '%s\n' "performance" > /sys/class/kgsl/kgsl-3d0/devfreq/governor
	printf '%d\n' "0" > /sys/class/kgsl/kgsl-3d0/default_pwrlevel
	printf '%d\n' "0" > /sys/class/kgsl/kgsl-3d0/thermal_pwrlevel
	printf '%d\n' "0" > /sys/class/kgsl/kgsl-3d0/min_pwrlevel
	printf '%d\n' "0" > /sys/class/kgsl/kgsl-3d0/throttling
}

#--------------------------------------------------------------
# Remove vendor thermal-engine*.conf files
#--------------------------------------------------------------
[[ -f /vendor/etc/thermal-engine.conf ]] && {
	mount -o remount,rw /vendor &>/dev/null
	rm -rf /vendor/etc/thermal-engine*.conf 2>/dev/null
	mount -o remount,ro /vendor &>/dev/null
}

#--------------------------------------------------------------
# Change cpusets to all available CPUs
#--------------------------------------------------------------
cpu_core_count="$(cat /sys/devices/system/cpu/online)"
for dev_cpuset in /dev/cpuset/*/cpus; do
	printf '%s\n' "$cpu_core_count" > "$dev_cpuset"
done

#--------------------------------------------------------------
# Enable USB OTG on certain devices
#--------------------------------------------------------------
[[ -f /sys/class/power_supply/usb/otg_switch ]] && {
	printf '%d\n' "1" > /sys/class/power_supply/usb/otg_switch
}

#--------------------------------------------------------------
# Create swapfile and disable ZRAM
#--------------------------------------------------------------
[[ -f $MODDIR/swapfile0 ]] && {
	rm -rf "$MODDIR"/swapfile0 2>/dev/null
}

fallocate -l 4G "$MODDIR/swapfile0" &&
chown root:root "$MODDIR/swapfile0" &&
chmod 0600 "$MODDIR/swapfile0" &&
mkswap "$MODDIR/swapfile0" &&
swapon "$MODDIR/swapfile0"

[[ $(cat /proc/swaps) == *zram0* ]] && {
	swapoff /dev/block/zram0
}

#--------------------------------------------------------------
# Show clock seconds in status bar
#--------------------------------------------------------------
settings put secure clock_seconds 1

#--------------------------------------------------------------
# Disable private DNS
#--------------------------------------------------------------
settings put global private_dns_mode off

#--------------------------------------------------------------
# Disable captive portal detection
#--------------------------------------------------------------
settings put global captive_portal_detection_enabled 0
settings put global captive_portal_mode 0

#--------------------------------------------------------------
# Change default NTP server
#--------------------------------------------------------------
settings put global ntp_server pool.ntp.org

#--------------------------------------------------------------
# Disable monitoring and killing of phantom app processes
#--------------------------------------------------------------
settings put global settings_enable_monitor_phantom_procs false
resetprop persist.sys.fflag.override.settings_enable_monitor_phantom_procs false

#--------------------------------------------------------------
# Increase max phantom process limit
#--------------------------------------------------------------
device_config put activity_manager max_phantom_processes 2147483647

#--------------------------------------------------------------
# Increase max cached process limit
#--------------------------------------------------------------
device_config put activity_manager max_cached_processes 2048

exit 0
EOF
	}

	package_main() {
		print_warning "Creating 'tether.$current_date' Magisk module"
		print_aligned "This may take a while"
		printf '\n'

		download_dnscrypt "$@"
		download_bash "$@"
		download_zip "$@"
		download_tether "$@"
		populate_dir "$@"
		create_module_prop "$@"
		create_customize "$@"
		create_service "$@"

		# Add execute permissions to $package_tmp_dir binaries
		chmod +x "$package_tmp_dir"/system/bin/*
		export PATH="$package_tmp_dir":$PATH

		# Add custom fonts
		print_warning "Adding custom fonts"
		printf '\n'

		read -rep "Replace system fonts with Iosevka (y/n) " font_option
		printf '\n'
		case "$font_option" in
			 Y | y)
				# Select font variant
				printf '1. %s\n2. %s\n\n' "Sans-serif" "Slab-serif"
				read -rep "Select Iosevka typeface: " font_type
				printf '\n'
				case "$font_type" in
					1)
						font_variant="sans"
						download_custom_iosevka "$@"
						create_post_fs "$@"
					;;
					*)
						font_variant="slab"
						download_custom_iosevka "$@"
						create_post_fs "$@"
					;;
				esac
			;;
			*)
				print_warning "Skipping Iosevka font installation"
				printf '\n'
			;;
		esac

		# Populate font/ if custom font files exist
		[[ -f $tmp_dir/fonts/NotoSerif-Regular.ttf ]] && {
			print_warning "Adding user provided font files"
			printf '\n'
			mkdir -p "$package_tmp_dir/system/fonts" 2>/dev/null || print_write_error "$package_tmp_dir/system/fonts"
			cp -r "$tmp_dir"/fonts/*.ttf "$package_tmp_dir/system/fonts" 2>/dev/null
			create_post_fs "$@"
		}

		# update module version
		sed -i "s/version\=.*/version\=$current_date/" "$package_tmp_dir/module.prop" 2>/dev/null

		# update module description
		[[ $font_option == "y" || $font_option == "Y" ]] && {
			sed -i "s/description\=.*/description\=Installs tether, changes system fonts to Iosevka, sets CPU and GPU governor to 'performance', disables ZRAM, enables swap and removes software controlled thermal limits\./" "$package_tmp_dir/module.prop" 2>/dev/null
		}

		[[ $font_option != "y" && $font_option != "Y" ]] && {
			sed -i "s/description\=.*/description\=Installs tether, sets CPU and GPU governor to 'performance', disables ZRAM, enables swap and removes software controlled thermal limits\./" "$package_tmp_dir/module.prop" 2>/dev/null
		}

		# Copy module files to tether/
		mkdir -p "$tmp_dir/tether" 2>/dev/null || print_write_error "$tmp_dir/tether"
		cp -rf "$package_tmp_dir"/* "$tmp_dir"/tether 2>/dev/null

		# Create magisk files
		mkdir -p "$tmp_dir/tether/META-INF/com/google/android" 2>/dev/null || print_write_error "$tmp_dir/tether/META-INF/com/google/android"
		printf  '%s\n' "#MAGISK" > "$tmp_dir/tether/META-INF/com/google/android/updater-script"

		cat 2>/dev/null << "EOF" > "$tmp_dir/tether/META-INF/com/google/android/update-binary"
#!/sbin/sh

#################
# Initialization
#################

umask 022

# echo before loading util_functions
ui_print() { echo "$1"; }

require_new_magisk() {
  ui_print "*******************************"
  ui_print " Please install Magisk v20.4+! "
  ui_print "*******************************"
  exit 1
}

#########################
# Load util_functions.sh
#########################

OUTFD=$2
ZIPFILE=$3

mount /data 2>/dev/null

[ -f /data/adb/magisk/util_functions.sh ] || require_new_magisk
. /data/adb/magisk/util_functions.sh
[ $MAGISK_VER_CODE -lt 20400 ] && require_new_magisk

install_module
exit 0
EOF

		cd "$tmp_dir/tether" 2>/dev/null || print_dir_change_error "${tmp_dir}/tether"

		print_warning "Almost done"
		print_aligned "Creating archive file 'tether.$current_date.zip'"
		printf '\n'

		# Zip tether/ contents
		7z a -snl -snh -tzip -mx1 -mmt"$CPU_CORE_COUNT" "tether.$current_date.zip" "*" &>/dev/null ||
		failed_to_create "$@"

		# Move module archive to external storage if available
		[[ -d "$EXTERNAL_STORAGE" ]] && {
			mkdir -p "$backup_dir" 2>/dev/null || print_write_error "$backup_dir"
			cp -rf "$tmp_dir/tether/tether.$current_date.zip" "$backup_dir" 2>/dev/null || print_file_write_error "$backup_dir/tether.$current_date.zip"
			print_success "Finished creating 'tether.$current_date.zip'"
			print_aligned "Check '$backup_dir'"
			rm -r "$package_tmp_dir" "$tmp_dir/tether" 2>/dev/null
			cd "$current_dir" 2>/dev/null || print_dir_change_error "${current_dir}"
			exit 0
		}

		cp -rf "$tmp_dir/tether/tether.$current_date.zip" "$PHONE_STORAGE" 2>/dev/null || print_file_write_error "$PHONE_STORAGE/tether.$current_date.zip"
		print_success "Finished creating 'tether.$current_date.zip'"
		print_aligned "Check '${PHONE_STORAGE}'"
		rm -r "$package_tmp_dir" "$tmp_dir/tether" 2>/dev/null
		cd "$current_dir" 2>/dev/null || print_dir_change_error "${current_dir}"
		exit 0
	}

	trap 'remove_file_on_exit "$package_tmp_dir" "$tmp_dir/tether"' 1 2 3 15
	input_option_type_two "$@"
	check_dependencies "$@"
	package_main "$@"
	exit
}

#--------------------------------------------------------------
# Platform: Android
# Dependencies: mount, umount
#--------------------------------------------------------------
replace-su() {
	print_help() {
echo -e "\033[1;97mNAME\033[00m
	$SCRIPT_NAME - su removal tool.

\033[1;97mSYNOPSIS\033[00m
	$SCRIPT_NAME [OPTION]

\033[1;97mDESCRIPTION\033[00m
	\033[1;97m$SCRIPT_NAME\033[00m removes phh-su from AOSP GSIs. phh-su is installed
	by default on AOSP GSIs and as such causes conflicts with Magisk.
	Flash device stock boot image, gain root access with phh-su and run
	this program to remove phh-su. This program will only work on Android >= 12

	\033[1;97m-h, --help\033[00m
		display this help message and exit.

	\033[1;97m-V, --version\033[00m
		output version information and exit.

\033[1;97mAUTHOR\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.
	Written by Kolade Ayomide Olanrewaju.

\033[1;97mREPORTING BUGS\033[00m
	Create a new issue at <https://github.com/teth3r/tether/>.

\033[1;97mCOPYRIGHT\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.

tether $SCRIPT_VERSION"
exit 0
	}

	check_dependencies() {
		# Only run on Android
		[[ ! -d /system/app/ || ! -f /system/build.prop ]] && {
			print_os_error
		}

		# Only run on Android >= 12
		[[ $ANDROID_VERSION -le 11 ]] && {
			print_os_error
		}

		# Only run on treble GSI ROM
		[[ ! $(getprop init.svc.phh_on_boot) ]] && {
			print_os_error
		}

		# Check if magisk is installed
		[[ -f /system/bin/su && -f /system/bin/magisk ]] || [[ ! -d /system/xbin ]] && {
			print_error "Magisk is already the default root solution"
			exit 1
		}

		# Check for required dependencies
		for mis_dep in mount umount; do
			[[ ! $(type -p "$mis_dep") ]] && {
				print_missing_dependencies "$mis_dep"
			}
		done

		# Show magisk warning
		[[ $(magisk -V 2>/dev/null) -ge 26000 ]] && {
			print_error "magisk has to be uninstalled first"
			exit 1
		}
	}

	failure_to_remount() {
		print_error "Failed to remount /system as RW"
		exit 1
	}

	replace_root() {
		# mount /system as RW only work on vndk-lite variants
		mount -o remount,rw / &>/dev/null || failure_to_remount "$@"
		rm -r "/system/bin/phh-remotectl.sh" 2>/dev/null
		rm -r "/system/bin/phh-securize.sh" 2>/dev/null
		rm -r "/system/bin/phh-su" 2>/dev/null
		rm -r "/system/etc/init/su.rc" 2>/dev/null
		rm -r "/system/etc/init/phh-remotectl.rc" 2>/dev/null
		umount -lf /system/xbin &>/dev/null
		rm -r "/system/xbin" 2>/dev/null
		mount -o remount,ro / &>/dev/null
		print_success "PHH-SU has been removed successfully"
		print_aligned "Reboot your device"
		exit 0
	}

	trap 'run_on_exit' 1 2 3 15
	input_option_type_two "$@"
	check_dependencies "$@"
	replace_root "$@"
	exit
}

#--------------------------------------------------------------
# Platform: voidlinux
# Dependencies: xbps, ping, ls, sed, grep, ln
#--------------------------------------------------------------
setup() {
	print_help() {
echo -e "\033[1;97mNAME\033[00m
	$SCRIPT_NAME - setup tool for void linux.

\033[1;97mSYNOPSIS\033[00m
	$SCRIPT_NAME [OPTION]

\033[1;97mDESCRIPTION\033[00m
	\033[1;97m$SCRIPT_NAME\033[00m provides an interactive CLI for the installation of useful
	software on Void Linux.
	\033[1;97mNOTE:\033[00m This program does not install Void Linux itself, only it's
	components, i.e the desktop environment or graphic drivers.

	\033[1;97m-h, --help\033[00m
		display this help message and exit.

	\033[1;97m-V, --version\033[00m
		output version information and exit.

\033[1;97mAUTHOR\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.
	Written by Kolade Ayomide Olanrewaju.

\033[1;97mREPORTING BUGS\033[00m
	Create a new issue at <https://github.com/teth3r/tether/>.

\033[1;97mCOPYRIGHT\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.

tether $SCRIPT_VERSION"
exit 0
	}

	check_dependencies() {
		# Only run on proper linux installs
		[[ -d /system/app || ! -d /proc/1 ]] && print_os_error

		# Handles Linux desktop including Virtual Machines
		[[ -d /sys/class/kgsl || -d /sys/class/power_supply/battery || -d /proc/gpufreq ]] && print_os_error

		# Only run on Void linux
		source "/etc/os-release" 2>/dev/null
		[[ $PRETTY_NAME != "Void Linux" ]] && print_os_error

		# Only run as root-user
		print_not_root_user

		# Check for required dependencies
		for mis_dep in xbps-install ping; do
			[[ ! $(type -p "$mis_dep") ]] && {
				print_missing_dependencies "$mis_dep"
			}
		done

		[[ ! $(ping -c4 voidlinux.org 2>/dev/null) ]] && {
			print_error "Failed to detect an internet connection"
			exit 1
		}
	}

	install_desktop() {
		desktop_kde() {
			xbps-install -Syu xbps void-repo-multilib void-repo-nonfree kde5 dolphin kdegraphics-thumbnailers spectacle okular gwenview xorg sddm rhythmbox papirus-icon-theme ffmpegthumbnailer noto-fonts-cjk &&
			sudo xbps-install -Syu &&

			# Add Dbus service
			ln -sf /etc/sv/dbus /var/service/

			# Remove conflicting desktop/session managers
			[[ -d /var/service/gdm ]] && {
				sv down gdm
				rm -r /var/service/gdm
			}

			[[ -d /var/service/lightdm ]] && {
				sv down lightdm
				rm -r /var/service/lightdm
			}

			# Disable acpid service
			[[ -d /var/service/acpid ]] && {
				sv down acpid
				rm -r /var/service/acpid
			}

			# Remove unnecessary ttys
			[[ -d /var/service/agetty-tty3 ]] && {
				sv down agetty-tty3
				sv down agetty-tty4
				sv down agetty-tty5
				sv down agetty-tty6
				rm -rf /var/service/agetty-tty3
				rm -rf /var/service/agetty-tty4
				rm -rf /var/service/agetty-tty5
				rm -rf /var/service/agetty-tty6
			}

			# Remove gnome tweaks/customizations for qt5 programs if present
			env_var_file="$(< /etc/environment)"
			[[ $env_var_file == *QT_LOGGING_RULES* ]] && {
				sed -i 's|QT_QPA_PLATFORMTHEME=qt5ct||g' /etc/environment
				sed -i 's|QT_LOGGING_RULES="qt.svg*.warning=false"||g' /etc/environment
			}

			ln -sf /etc/sv/sddm /var/service/
		}

		desktop_gnome() {
			xbps-install -Syu xbps void-repo-multilib void-repo-nonfree gnome-core gdm dbus xorg gnome-tweaks eog qt5ct rhythmbox fontmanager totem papirus-icon-theme ffmpegthumbnailer noto-fonts-cjk &&
			sudo xbps-install -Syu &&

			# Add Dbus service
			ln -sf /etc/sv/dbus /var/service/

			# Remove conflicting desktop/session managers
			[[ -d /var/service/sddm ]] && {
				sv down sddm
				rm -r /var/service/sddm
			}

			[[ -d /var/service/lightdm ]] && {
				sv down lightdm
				rm -r /var/service/lightdm
			}

			# Disable acpid service
			[[ -d /var/service/acpid ]] && {
				sv down acpid
				rm -r /var/service/acpid
			}

			# Remove unnecessary ttys
			[[ -d /var/service/agetty-tty3 ]] && {
				sv down agetty-tty3
				sv down agetty-tty4
				sv down agetty-tty5
				sv down agetty-tty6
				rm -rf /var/service/agetty-tty3
				rm -rf /var/service/agetty-tty4
				rm -rf /var/service/agetty-tty5
				rm -rf /var/service/agetty-tty6
			}

			# Enable tweaks/customizations for qt5 programs
			env_var_file="$(< /etc/environment)"
			[[ $env_var_file != *QT_QPA_PLATFORMTHEME* ]] && {
				printf '%s\n' "QT_QPA_PLATFORMTHEME=qt5ct" >> /etc/environment
				printf '%s\n' "QT_LOGGING_RULES=\"qt.svg*.warning=false\"" >> /etc/environment
			}

			# Fixes missing icon bug
			xbps-reconfigure -af

			# Start gdm
			ln -sf /etc/sv/gdm /var/service/
		}

		desktop_xfce() {
			xbps-install -Syu xbps void-repo-multilib void-repo-nonfree pavucontrol dbus xorg xfce4 xfwm4 lightdm lightdm-gtk-greeter lightdm-gtk3-greeter lightdm-gtk-greeter-settings papirus-icon-theme ffmpegthumbnailer noto-fonts-cjk &&
			sudo xbps-install -Syu &&

			# Add Dbus service
			ln -sf /etc/sv/dbus /var/service/

			# Remove conflicting desktop/session managers
			[[ -d /var/service/gdm ]] && {
				sv down gdm
				rm -r /var/service/gdm
			}

			[[ -d /var/service/sddm ]] && {
				sv down sddm
				rm -r /var/service/sddm
			}

			# Disable acpid service
			[[ -d /var/service/acpid ]] && {
				sv down acpid
				rm -r /var/service/acpid
			}

			# Remove unnecessary ttys
			[[ -d /var/service/agetty-tty3 ]] && {
				sv down agetty-tty3
				sv down agetty-tty4
				sv down agetty-tty5
				sv down agetty-tty6
				rm -rf /var/service/agetty-tty3
				rm -rf /var/service/agetty-tty4
				rm -rf /var/service/agetty-tty5
				rm -rf /var/service/agetty-tty6
			}

			ln -sf /etc/sv/lightdm /var/service/
		}

		desktop_cinnamon() {
			xbps-install -Syu xbps void-repo-multilib void-repo-nonfree pavucontrol dbus xorg cinnamon lightdm lightdm-gtk-greeter lightdm-gtk3-greeter lightdm-gtk-greeter-settings papirus-icon-theme ffmpegthumbnailer noto-fonts-cjk &&
			sudo xbps-install -Syu &&

			# Add Dbus service
			ln -sf /etc/sv/dbus /var/service/

			# Remove conflicting desktop/session managers
			[[ -d /var/service/gdm ]] && {
				sv down gdm
				rm -r /var/service/gdm
			}

			[[ -d /var/service/sddm ]] && {
				sv down sddm
				rm -r /var/service/sddm
			}

			# Disable acpid service
			[[ -d /var/service/acpid ]] && {
				sv down acpid
				rm -r /var/service/acpid
			}

			# Remove unnecessary ttys
			[[ -d /var/service/agetty-tty3 ]] && {
				sv down agetty-tty3
				sv down agetty-tty4
				sv down agetty-tty5
				sv down agetty-tty6
				rm -rf /var/service/agetty-tty3
				rm -rf /var/service/agetty-tty4
				rm -rf /var/service/agetty-tty5
				rm -rf /var/service/agetty-tty6
			}

			ln -sf /etc/sv/lightdm /var/service/
		}
	}

	install_gpu_drivers() {
		intel_drivers() {
			# Update xbps, enable multi-lib repo and non-free repo
			xbps-install -Syu xbps void-repo-multilib void-repo-nonfree &&
			xbps-install -Syu linux-firmware-intel mesa-dri mesa-dri-32bit vulkan-loader mesa-vulkan-intel intel-video-accel xf86-video-intel

			sysctl_file="$(< /etc/sysctl.conf)"
			[[ $sysctl_file != *dev.i915.perf_stream_paranoid* ]] && {
				printf '%s\n' "dev.i915.perf_stream_paranoid = 0" >> /etc/sysctl.conf
			}

			# Install microcode-updates
			xbps-install -Syu intel-ucode
		}

		amd_drivers() {
			# Update xbps, enable multi-lib repo and non-free repo
			xbps-install -Syu xbps void-repo-multilib void-repo-nonfree &&
			xbps-install -Syu linux-firmware-amd mesa-dri mesa-dri-32bit vulkan-loader mesa-vulkan-radeon amdvlk xf86-video-amdgpu xf86-video-ati mesa-vaapi mesa-vdpau
		}
	}

	install_audio() {
		pulse_audio() {
			# Update xbps, enable multi-lib repo and non-free repo
			xbps-install -Syu xbps void-repo-multilib void-repo-nonfree &&
			xbps-install -Syu pulseaudio
		}

		alsa_utils() {
			# Update xbps, enable multi-lib repo and non-free repo
			xbps-install -Syu xbps void-repo-multilib void-repo-nonfree &&
			xbps-install -Syu alsa-utils apulse &&
			ln -sf /etc/sv/alsa /var/service &&
			usermod -aG audio "$SUDO_USER"
		}

		pipe_wire() {
			# Update xbps, enable multi-lib repo and non-free repo
			xbps-install -Syu xbps void-repo-multilib void-repo-nonfree &&
			xbps-install -Syu pipewire wireplumber libspa-bluetooth
		}
	}

	install_terminal() {
		install_urxvt() {
			# Update xbps, enable multi-lib repo and non-free repo
			xbps-install -Syu xbps void-repo-multilib void-repo-nonfree &&
			xbps-install -Syu rxvt-unicode

			# Create vim file association
			mkdir -p "/home/$SUDO_USER/.local/share/applications" || print_write_error "/home/$SUDO_USER/.local/share/applications"
			chown -R "$SUDO_USER":"$SUDO_USER" /home/"$SUDO_USER"/.local/ 2>/dev/null
			cat 2>/dev/null << "EOF" > "/home/$SUDO_USER/.local/share/applications/vim.desktop"
[Desktop Entry]
Version=1.0
Name=vim
Comment=Screen-based text editor program
Exec=urxvt -e vim %f
Icon=konsole
Type=Application
MimeType=text/plain;
EOF
			chown "${SUDO_USER:=$USER}":"${SUDO_USER:=$USER}" "/home/${SUDO_USER:=$USER}/.local/share/applications/vim.desktop" 2>/dev/null

			# Change uxrvt app/file icon
			[[ $(< /usr/share/applications/rxvt-unicode.desktop) != *konsole* ]] && {
				sed -i 's|Icon=rxvt-unicode|Icon=konsole|g' /usr/share/applications/rxvt-unicode.desktop
			}
		}

		install_kitty() {
			# Update xbps, enable multi-lib repo and non-free repo
			xbps-install -Syu xbps void-repo-multilib void-repo-nonfree &&
			xbps-install -Syu kitty

			# Create vim file association
			mkdir -p "/home/$SUDO_USER/.local/share/applications" || print_write_error "/home/$SUDO_USER/.local/share/applications"
			chown -R "$SUDO_USER":"$SUDO_USER" "/home/$SUDO_USER/.local/" 2>/dev/null
			cat 2>/dev/null << "EOF" > "/home/$SUDO_USER/.local/share/applications/vim.desktop"
[Desktop Entry]
Version=1.0
Name=vim
Comment=Screen-based text editor program
Exec=kitty -e vim %f
Icon=kitty
Type=Application
MimeType=text/plain;
EOF
			chown "${SUDO_USER:=$USER}":"${SUDO_USER:=$USER}" /home/"${SUDO_USER:=$USER}"/.local/share/applications/vim.desktop 2>/dev/null
		}
	}

	install_extras() {
		# Disble ssh server
		[[ -d /var/service/sshd ]] && {
			sv down sshd
			rm -r /var/service/sshd
		}

		# Update xbps, enable multi-lib repo and non-free repo
		xbps-install -Syu xbps void-repo-multilib void-repo-nonfree &&

		# Install useful GUI software
		xbps-install -Syu nicotine+ qbittorrent tageditor libreoffice gimp &&

		# Install gaming software
		xbps-install -Syu wine wine-32bit libwine libwine-32bit wine-mono winetricks
	}

	install_dev_software() {
		# Update xbps, enable multi-lib repo and non-free repo
		xbps-install -Syu xbps void-repo-multilib void-repo-nonfree &&

		# Install development software
		xbps-install -Syu tmux bash-completion gcc git rust cargo

		# Incase no vim-huge exists i.e on ARM systems
		xbps-install -Syu vim-huge

		# Install Android specific tools
		xbps-install -Syu android-tools android-udev-rules gvfs gvfs-mtp &&

		# Install useful CLI software
		xbps-install -Syu smartmontools unzip bsdtar wget bc ldns ntfs-3g udftools man 7zip 7zip-unrar libhwloc &&

		# Required for ADB and fastboot
		usermod -aG plugdev "$SUDO_USER"

		# Update man pages
		makewhatis /usr/share/man
	}

	install_browser() {
		chromium() {
			# Update xbps, enable multi-lib repo and non-free repo
			xbps-install -Syu xbps void-repo-multilib void-repo-nonfree &&
			xbps-install -Syu chromium
		}

		firefox() {
			# Update xbps, enable multi-lib repo and non-free repo
			xbps-install -Syu xbps void-repo-multilib void-repo-nonfree &&
			xbps-install -Syu firefox
		}
	}

	install_media_player() {
		vlc() {
			# Update xbps, enable multi-lib repo and non-free repo
			xbps-install -Syu xbps void-repo-multilib void-repo-nonfree &&
			xbps-install -Syu vlc
		}

		mpv() {
			# Update xbps, enable multi-lib repo and non-free repo
			xbps-install -Syu xbps void-repo-multilib void-repo-nonfree &&
			sudo xbps-install -Syu mpv
		}
	}

	install_vm() {
		# Update xbps, enable multi-lib repo and non-free repo
		xbps-install -Syu xbps void-repo-multilib void-repo-nonfree &&
		xbps-install -Syu virt-manager qemu &&
		ln -sf /etc/sv/libvirtd /var/service/ &&
		ln -sf /etc/sv/virtlockd /var/service/ &&
		ln -sf /etc/sv/virtlogd /var/service/ &&
		usermod -aG libvirt "$SUDO_USER"
	}

	install_printer_drivers() {
		hp_printer() {
			# Update xbps, enable multi-lib repo and non-free repo
			xbps-install -Syu xbps void-repo-multilib void-repo-nonfree &&
			xbps-install -Syu cups hplip-gui xsane cups-filters &&
			ln -sf /etc/sv/cupsd /var/service/
		}

		brother_printer() {
			# Update xbps, enable multi-lib repo and non-free repo
			xbps-install -Syu xbps void-repo-multilib void-repo-nonfree &&
			sudo xbps-install -Syu cups cups-filters brother-brlaser xsane &&
			ln -sf /etc/sv/cupsd /var/service/
		}

		epson_printer() {
			# Update xbps, enable multi-lib repo and non-free repo
			xbps-install -Syu xbps void-repo-multilib void-repo-nonfree &&
			sudo xbps-install -Syu cups cups-filters epson-inkjet-printer-escpr imagescan iscan-data &&
			ln -sf /etc/sv/cupsd /var/service/
		}
	}

	install_backlight_control() {
		init_program="$(< /proc/1/status)"
		init_program="${init_program/*Name:}"
		init_program="${init_program/Umask:*}"
		init_program="${init_program//[[:space:]]}"

		[[ $init_program != "runit" ]] && {
			return 1
		}

		[[ ! -f /sys/class/power_supply/BAT0/capacity ]] && {
			error_check="no_battery"
			return 1
		}

		[[ $init_program == "runit" ]] && {
			# Add automatic backlight control to runsvdir
			mkdir -p /var/service/backlight

			cat << "EOF" > /var/service/backlight/run
#!/bin/env bash

# Simple script to adjust system backlight automatically

unset system_set

while :; do
	for device_name in /sys/class/backlight/*; do
		[[ -f $device_name/brightness ]] && {
			# Current brightness level
			cur_value="$(< $device_name/brightness)"
			# Battery percentage
			bat_capacity="$(< /sys/class/power_supply/BAT0/capacity)"
			# Battery status
			bat_status="$(< /sys/class/power_supply/BAT0/status)"
			# Handles battery when unplugged and <= 30%
			[[ $bat_status == "Discharging" && $bat_capacity -le 30 ]] && {
				# Prevent changing current brightness level, in case user increases it manually
				[[ $cur_value -eq 77 || $system_set -eq 1 ]] && {
					system_set=1
					break
				}
				# Set backlight to 30%
				printf '%d\n' "77" > "$device_name/brightness"
				# Turn off keyboard backlight to save power
				for kbd in /sys/class/leds/*kbd_backlight; do
					[[ -f $kbd ]] && {
						printf '%d\n' "0" > "$kbd/brightness"
					}
				done
				system_set=1
			}
			# Handles battery when unplugged and > 30%
			[[ $bat_status == "Discharging" && $bat_capacity -gt 30 ]] && {
				# Prevent changing current brightness level, in case user increases it manually
				[[ $cur_value -eq 128 || $system_set -eq 2 ]] && {
					system_set=2
					break
				}
				# Set backlight to 50%
				printf '%d\n' "128" > "$device_name/brightness"
				system_set=2
			}
			# Handles battery when plugged in or battery is 100%
			[[ $bat_status == "Full" || $bat_status == "Charging" ]] && {
				# Prevent changing current brightness level, in case user increases it manually
				[[ $cur_value -eq 179 || $system_set -eq 3 ]] && {
					system_set=3
					break
				}
				# Set backlight to 70%
				printf '%d\n' "179" > "$device_name/brightness"
				system_set=3
			}
		}
	done
	# Poll for changes
	read -rt "2" <> <(:) || :
done
EOF
			chmod +x /var/service/backlight/run &&
			printf '%s\n' "Done"
		}
	}

	install_networking() {
		# Update xbps, enable multi-lib repo and non-free repo
		xbps-install -Syu xbps void-repo-multilib void-repo-nonfree &&
		xbps-install -Syu git dnscrypt-proxy NetworkManager bluez

		[[ -d /var/service/dhcpcd ]] && {
			sv down dhcpcd
			rm -r /var/service/dhcpcd
		}

		[[ -d /var/service/wpa_supplicant ]] && {
			sv down wpa_supplicant
			rm -r /var/service/wpa_supplicant
		}

		# Network Manager
		[[ ! -d /var/service/NetworkManager ]] && {
			ln -sf /etc/sv/NetworkManager /var/service/
		}

		# Bluetooth
		[[ ! -d /var/service/bluetoothd ]] && {
			ln -sf /etc/sv/bluetoothd /var/service/
		}

		usermod -aG bluetooth "$SUDO_USER"

		# Dnscrypt-proxy
		mkdir -p /etc/dnscrypt-proxy
		git clone "https://github.com/teth3r/blocklist" &&
		cp -rf blocklist/*.txt /etc/dnscrypt-proxy &&
		cp -rf blocklist/*.toml /etc/dnscrypt-proxy &&
		rm -r blocklist &&

		# Force TCP usage for connecting to upstream resolvers
		sed -i 's/force_tcp\ =\ false/force_tcp\ =\ true/' /etc/dnscrypt-proxy/dnscrypt-proxy.toml
		chown -R "$SUDO_USER":"$SUDO_USER" /etc/dnscrypt-proxy 2>/dev/null

		# Make resolv.conf immutable
		chattr -i /etc/resolv.conf

		printf '%s\n' "nameserver 127.0.0.1" > /etc/resolv.conf

		chattr +i /etc/resolv.conf

		[[ ! -d /var/service/dnscrypt-proxy ]] && {
			ln -sf /etc/sv/dnscrypt-proxy /var/service/
		}

		sv up dnscrypt-proxy
	}

	get_user_options() {
		print_banner
		print_warning "Setting up Voidlinux"

		# Handles DE Installation
		printf '\nInstall Desktop Environment: \n1. KDE \n2. Gnome \n3. Xfce \n4. Cinnamon \n5. Skip \n6. Exit\n\n'
		read -rep "Select Desktop: " de_option
		printf '\n'
		case "$de_option" in
			1)
				print_warning "Installing KDE"
				printf '\n'
				install_desktop && desktop_kde && error_check="desktop" &&
				printf '\n' &&
				print_success "Finished installing KDE"
			;;
			2)
				print_warning "Installing Gnome"
				printf '\n'
				install_desktop && desktop_gnome && error_check="desktop" &&
				printf '\n' &&
				print_success "Finished installing Gnome"
			;;
			3)
				print_warning "Installing Xfce"
				printf '\n'
				install_desktop && desktop_xfce && error_check="desktop" &&
				printf '\n' &&
				print_success "Finished installing Xfce"
			;;
			4)
				print_warning "Installing Cinnamon"
				printf '\n'
				install_desktop && desktop_cinnamon && error_check="desktop" &&
				printf '\n' &&
				print_success "Finished installing Cinnamon"
			;;
			5)
				print_warning "Skipping Desktop Environment Installation"
				error_check="desktop"
			;;
			6)
				print_error "Aborted" &&
				exit 1
			;;
			-*)
				[[ -z ${de_option#*\-} || -z ${de_option/\-\-*} ]] && {
					print_error "Unrecognized option '${de_option}'" &&
					exit 1
				}

				print_error "Invalid option -- '${de_option#*\-}'" &&
				exit 1
			;;
			*)
				print_error "Unrecognized option '${de_option}'" &&
				exit 1
			;;
		esac

		[[ $error_check != "desktop" ]] && {
			printf '\n'
			print_error "Something went wrong"
			print_aligned "Couldn't install Desktop Environment"
			exit 1
		}

		# Handles GPU Driver Installation
		printf '\nInstall GPU Drivers: \n1. Intel \n2. AMD/radeon \n3. Skip \n4. Exit\n\n'
		read -rep "Select GPU: " gpu_option
		printf '\n'
		case "$gpu_option" in
			1)
				print_warning "Installing Intel GPU Drivers"
				printf '\n'
				install_gpu_drivers && intel_drivers && error_check="gpu" &&
				printf '\n' &&
				print_success "Finished installing Intel GPU Drivers"
			;;
			2)
				print_warning "Installing AMD GPU Drivers"
				printf '\n'
				install_gpu_drivers && amd_drivers && error_check="gpu" &&
				printf '\n' &&
				print_success "Finished installing AMD GPU Drivers"
			;;
			3)
				print_warning "Skipping GPU Driver Installation"
				error_check="gpu"
			;;
			4)
				print_error "Aborted" &&
				exit 1
			;;
			-*)
				[[ -z ${gpu_option#*\-} || -z ${gpu_option/\-\-*} ]] && {
					print_error "Unrecognized option '${gpu_option}'" &&
					exit 1
				}

				print_error "Invalid option -- '${gpu_option#*\-}'" &&
				exit 1
			;;
			*)
				print_error "Unrecognized option '${gpu_option}'" &&
				exit 1
			;;
		esac

		[[ $error_check != "gpu" ]] && {
			printf '\n'
			print_error "Something went wrong"
			print_aligned "Couldn't install GPU drivers"
			exit 1
		}

		# Handles VM Software Installation
		printf '\nInstall VM Software (qemu, virt-manager): \n1. Yes \n2. Skip \n3. Exit\n\n'
		read -rep "Select option: " vm_option
		printf '\n'
		case "$vm_option" in
			1)
				print_warning "Installing Virtual Machine software"
				printf '\n'
				install_vm && error_check="vm" &&
				printf '\n' &&
				print_success "Finished installing Virtual Machine software"
			;;
			2)
				print_warning "Skipping VM Software Installation"
				error_check="vm"
			;;
			3)
				print_error "Aborted" &&
				exit 1
			;;
			-*)
				[[ -z ${vm_option#*\-} || -z ${vm_option/\-\-*} ]] && {
					print_error "Unrecognized option '${vm_option}'" &&
					exit 1
				}

				print_error "Invalid option -- '${vm_option#*\-}'" &&
				exit 1
			;;
			*)
				print_error "Unrecognized option '${vm_option}'" &&
				exit 1
			;;
		esac

		[[ $error_check != "vm" ]] && {
			printf '\n'
			print_error "Something went wrong"
			print_aligned "Couldn't install VM software"
			exit 1
		}

		# Handles Printer Software Installation
		printf '\nInstall Printer Software: \n1. HP \n2. Epson \n3. Brother \n4. Skip \n5. Exit\n\n'
		read -rep "Select Printer: " printer_option
		printf '\n'
		case "$printer_option" in
			1)
				print_warning "Installing HP Printer Software"
				printf '\n'
				install_printer_drivers && hp_printer && error_check="printer" &&
				printf '\n' &&
				print_success "Finished installing HP Printer software"
			;;
			2)
				print_warning "Installing Epson Printer Software"
				printf '\n'
				install_printer_drivers && epson_printer && error_check="printer" &&
				printf '\n' &&
				print_success "Finished installing Epson Printer software"
			;;
			3)
				print_warning "Installing Brother Printer Software"
				printf '\n'
				install_printer_drivers && brother_printer && error_check="printer" &&
				printf '\n' &&
				print_success "Finished installing Brother Printer software"
			;;
			4)
				print_warning "Skipping Printer Software Installation"
				error_check="printer"
			;;
			5)
				print_error "Aborted" &&
				exit 1
			;;
			-*)
				[[ -z ${printer_option#*\-} || -z ${printer_option/\-\-*} ]] && {
					print_error "Unrecognized option '${printer_option}'" &&
					exit 1
				}

				print_error "Invalid option -- '${printer_option#*\-}'" &&
				exit 1
			;;
			*)
				print_error "Unrecognized option '${printer_option}'" &&
				exit 1
			;;
		esac

		[[ $error_check != "printer" ]] && {
			printf '\n'
			print_error "Something went wrong"
			print_aligned "Couldn't install printer software"
			exit 1
		}

		# Handles Audio Software Installation
		printf '\nInstall Audio Software: \n1. Pulseaudio \n2. ALSA \n3. Pipewire \n4. Skip \n5. Exit\n\n'
		read -rep "Select Audio: " audio_option
		printf '\n'
		case "$audio_option" in
			1)
				print_warning "Installing Pulseaudio"
				printf '\n'
				install_audio && pulse_audio && error_check="audio" &&
				printf '\n' &&
				print_success "Finished installing Pulseaudio"
			;;
			2)
				print_warning "Installing ALSA"
				printf '\n'
				install_audio && alsa_utils && error_check="audio" &&
				printf '\n' &&
				print_success "Finished installing ALSA"
			;;
			3)
				print_warning "Installing Pipewire"
				printf '\n'
				install_audio && pipe_wire && error_check="audio" &&
				printf '\n' &&
				print_success "Finished installing Pipewire"
			;;
			4)
				print_warning "Skipping Audio Software Installation"
				error_check="audio"
			;;
			5)
				print_error "Aborted" &&
				exit 1
			;;
			-*)
				[[ -z ${audio_option#*\-} || -z ${audio_option/\-\-*} ]] && {
					print_error "Unrecognized option '${audio_option}'" &&
					exit 1
				}

				print_error "Invalid option -- '${audio_option#*\-}'" &&
				exit 1
			;;
			*)
				print_error "Unrecognized option '${audio_option}'" &&
				exit 1
			;;
		esac

		[[ $error_check != "audio" ]] && {
			printf '\n'
			print_error "Something went wrong"
			print_aligned "Couldn't install audio software"
			exit 1
		}

		# Handles Terminal Software Installation
		printf '\nInstall Terminal: \n1. Urxvt \n2. Kitty \n3. Skip \n4. Exit\n\n'
		read -rep "Select Terminal: " term_option
		printf '\n'
		case "$term_option" in
			1)
				print_warning "Installing Urxvt"
				printf '\n'
				install_terminal && install_urxvt "$@" && error_check="terminal" &&
				printf '\n' &&
				print_success "Finished installing Urxvt"
			;;
			2)
				print_warning "Installing Kitty"
				printf '\n'
				install_terminal && install_kitty "$@" && error_check="terminal" &&
				printf '\n' &&
				print_success "Finished installing Kitty"
			;;
			3)
				print_warning "Skipping Terminal Installation"
				error_check="terminal"
			;;
			4)
				print_error "Aborted" &&
				exit 1
			;;
			-*)
				[[ -z ${term_option#*\-} || -z ${term_option/\-\-*} ]] && {
					print_error "Unrecognized option '${term_option}'" &&
					exit 1
				}

				print_error "Invalid option -- '${term_option#*\-}'" &&
				exit 1
			;;
			*)
				print_error "Unrecognized option '${term_option}'" &&
				exit 1
			;;
		esac

		[[ $error_check != "terminal" ]] && {
			printf '\n'
			print_error "Something went wrong"
			print_aligned "Couldn't install terminal"
			exit 1
		}

		# Handles Extra Software Installation
		printf '\nInstall Extra/Misc Software (gimp, libreoffice, wine): \n1. Yes \n2. Skip \n3. Exit\n\n'
		read -rep "Select option: " extras_option
		printf '\n'
		case "$extras_option" in
			1)
				print_warning "Installing Extra/Misc Software"
				printf '\n'
				install_extras && error_check="extras" &&
				printf '\n' &&
				print_success "Finished installing Extra/Misc software"
			;;
			2)
				print_warning "Skipping Extra/Misc Software Installation"
				error_check="extras"
			;;
			3)
				print_error "Aborted" &&
				exit 1
			;;
			-*)
				[[ -z ${extras_option#*\-} || -z ${extras_option/\-\-*} ]] && {
					print_error "Unrecognized option '${extras_option}'" &&
					exit 1
				}

				print_error "Invalid option -- '${extras_option#*\-}'" &&
				exit 1
			;;
			*)
				print_error "Unrecognized option '${extras_option}'" &&
				exit 1
			;;
		esac

		[[ $error_check != "extras" ]] && {
			printf '\n'
			print_error "Something went wrong"
			print_aligned "Couldn't install extra/misc software"
			exit 1
		}

		# Handles Development Software Installation
		printf '\nInstall Development Software (gcc, rust, cargo, vim): \n1. Yes \n2. Skip \n3. Exit\n\n'
		read -rep "Select option: " dev_option
		printf '\n'
		case "$dev_option" in
			1)
				print_warning "Installing Development Software"
				printf '\n'
				install_dev_software && error_check="development" &&
				printf '\n' &&
				print_success "Finished installing development software"
			;;
			2)
				print_warning "Skipping Development Software Installation"
				error_check="development"
			;;
			3)
				print_error "Aborted" &&
				exit 1
			;;
			-*)
				[[ -z ${dev_option#*\-} || -z ${dev_option/\-\-*} ]] && {
					print_error "Unrecognized option '${dev_option}'" &&
					exit 1
				}

				print_error "Invalid option -- '${dev_option#*\-}'" &&
				exit 1
			;;
			*)
				print_error "Unrecognized option '${dev_option}'" &&
				exit 1
			;;
		esac

		[[ $error_check != "development" ]] && {
			printf '\n'
			print_error "Something went wrong"
			print_aligned "Couldn't install development software"
			exit 1
		}

		# Handles Browser Installation
		printf '\nInstall Browser Software: \n1. Chromium \n2. Firefox \n3. Skip \n4. Exit\n\n'
		read -rep "Select Browser: " browser_option
		printf '\n'
		case "$browser_option" in
			1)
				print_warning "Installing Chromium"
				printf '\n'
				install_browser && chromium && error_check="browser" &&
				printf '\n' &&
				print_success "Finished installing Chromium"
			;;
			2)
				print_warning "Installing Firefox"
				printf '\n'
				install_browser && firefox && error_check="browser" &&
				printf '\n' &&
				print_success "Finished installing Firefox"
			;;
			3)
				print_warning "Skipping Browser Software Installation"
				error_check="browser"
			;;
			4)
				print_error "Aborted" &&
				exit 1
			;;
			-*)
				[[ -z ${browser_option#*\-} || -z ${browser_option/\-\-*} ]] && {
					print_error "Unrecognized option '${browser_option}'" &&
					exit 1
				}

				print_error "Invalid option -- '${browser_option#*\-}'" &&
				exit 1
			;;
			*)
				print_error "Unrecognized option '${browser_option}'" &&
				exit 1
			;;
		esac

		[[ $error_check != "browser" ]] && {
			printf '\n'
			print_error "Something went wrong"
			print_aligned "Couldn't install browser software"
			exit 1
		}

		# Handles Media-Player Installation
		printf '\nInstall Media-Player Software: \n1. VLC \n2. MPV \n3. Skip \n4. Exit\n\n'
		read -rep "Select Media-Player: " media_player_option
		printf '\n'
		case "$media_player_option" in
			1)
				print_warning "Installing VLC"
				printf '\n'
				install_media_player && vlc && error_check="media_player" &&
				printf '\n' &&
				print_success "Finished installing VLC"
			;;
			2)
				print_warning "Installing MPV"
				printf '\n'
				install_media_player && mpv && error_check="media_player" &&
				printf '\n' &&
				print_success "Finished installing MPV"
			;;
			3)
				print_warning "Skipping Media-Player Software Installation"
				error_check="media_player"
			;;
			4)
				print_error "Aborted" &&
				exit 1
			;;
			-*)
				[[ -z ${media_player_option#*\-} || -z ${media_player_option/\-\-*} ]] && {
					print_error "Unrecognized option '${media_player_option}'" &&
					exit 1
				}

				print_error "Invalid option -- '${media_player_option#*\-}'" &&
				exit 1
			;;
			*)
				print_error "Unrecognized option '${media_player_option}'" &&
				exit 1
			;;
		esac

		[[ $error_check != "media_player" ]] && {
			print_error "Something went wrong"
			print_aligned "Couldn't install media-player software"
			exit 1
		}

		# Handles Setting timezone
		printf '\nChange Default Timezone: \n1. Yes \n2. Skip \n3. Exit\n\n'
		read -rep "Select option: " time_zone_option
		printf '\n'
		case "$time_zone_option" in
			1)
				print_warning "Changing Timezone"
				printf '\n'
				change_timezone "$@" && error_check="timezone" &&
				print_success "Finished Changing Timezone"
			;;
			2)
				print_warning "Skipping Timezone Change"
				error_check="timezone"
			;;
			3)
				print_error "Aborted" &&
				exit 1
			;;
			-*)
				[[ -z ${time_zone_option#*\-} || -z ${time_zone_option/\-\-*} ]] && {
					print_error "Unrecognized option '${time_zone_option}'" &&
					exit 1
				}

				print_error "Invalid option -- '${time_zone_option#*\-}'" &&
				exit 1
			;;
			*)
				print_error "Unrecognized option '${time_zone_option}'" &&
				exit 1
			;;
		esac

		[[ $error_check != "timezone" ]] && {
			print_error "Something went wrong"
			print_aligned "Couldn't change default timezone"
			exit 1
		}

		# Handles Automatic Backlight Control
		printf '\nInstall Automatic Backlight Control: \n1. Yes \n2. Skip \n3. Exit\n\n'
		read -rep "Select option: " auto_backlight_option
		printf '\n'
		case "$auto_backlight_option" in
			1)
				print_warning "Installing Automatic Backlight Control"
				printf '\n'
				install_backlight_control && error_check="auto_backlight" &&
				printf '\n' &&
				print_success "Finished installing Automatic Backlight Control"
			;;
			2)
				print_warning "Skipping Automatic Backlight Control"
				error_check="auto_backlight"
			;;
			3)
				print_error "Aborted" &&
				exit 1
			;;
			-*)
				[[ -z ${auto_backlight_option#*\-} || -z ${auto_backlight_option/\-\-*} ]] && {
					print_error "Unrecognized option '${auto_backlight_option}'" &&
					exit 1
				}

				print_error "Invalid option -- '${auto_backlight_option#*\-}'" &&
				exit 1
			;;
			*)
				print_error "Unrecognized option '${auto_backlight_option}'" &&
				exit 1
			;;
		esac

		[[ $error_check == "no_battery" ]] && {
			printf '\n'
			print_error "Battery not installed"
			exit 1
		}

		[[ $error_check != "auto_backlight" ]] && {
			printf '\n'
			print_error "Unsupported init detected"
			print_aligned "Couldn't install automatic backlight control"
			exit 1
		}

		# Handles Networking Software Installation
		printf '\nInstall Networking Software: \n1. Yes \n2. Skip \n3. Exit\n\n'
		read -rep "Select option: " network_option
		printf '\n'
		case "$network_option" in
			1)
				print_warning "Installing Networking Software"
				printf '\n'
				install_networking && error_check="network" &&
				printf '\n' &&
				print_success "Finished setting up void linux"
			;;
			2)
				print_warning "Skipping Networking Software Installation"
				printf '\n'
				print_error "Nothing left to do, exiting"
				error_check="network"
				exit 1
			;;
			3)
				print_error "Aborted" &&
				exit 1
			;;
			-*)
				[[ -z ${network_option#*\-} || -z ${network_option/\-\-*} ]] && {
					print_error "Unrecognized option '${network_option}'" &&
					exit 1
				}

				print_error "Invalid option -- '${network_option#*\-}'" &&
				exit 1
			;;
			*)
				print_error "Unrecognized option '${network_option}'" &&
				exit 1
			;;
		esac

		[[ $error_check != "network" ]] && {
			printf '\n'
			print_error "Something went wrong"
			print_aligned "Couldn't install networking software"
			exit 1
		}
	}

	trap 'run_on_exit' 1 2 3 15
	input_option_type_two "$@"
	check_dependencies "$@"
	get_user_options "$@"
	exit
}

#--------------------------------------------------------------
# Platform: Device Agnostic
# Dependencies: mkswap, swapon, swapoff, dd, df, awk
#--------------------------------------------------------------
swapfile() {
	print_help() {
echo -e "\033[1;97mNAME\033[00m
	$SCRIPT_NAME - swapfile manager.

\033[1;97mSYNOPSIS\033[00m
	$SCRIPT_NAME [OPTION] [FILESIZE] [FILENAME]

\033[1;97mDESCRIPTION\033[00m
	Perform system swapfile management on the go. This program will create
	or delete a specified swapfile.

	\033[1;97m-d, --disable\033[00m [FILENAME]
		disable and delete [FILENAME] swapfile.

	\033[1;97m-e, --enable\033[00m [FILESIZE] [FILENAME]
		create and enable [FILENAME] swapfile with size [FILESIZE].
		[FILESIZE] must be specified with the byte type i.e 2048MB.

	\033[1;97m-h, --help\033[00m
		display this help message and exit.

	\033[1;97m-V, --version\033[00m
		output version information and exit.

\033[1;97mAUTHOR\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.
	Written by Kolade Ayomide Olanrewaju.

\033[1;97mREPORTING BUGS\033[00m
	Create a new issue at <https://github.com/teth3r/tether/>.

\033[1;97mCOPYRIGHT\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.

tether $SCRIPT_VERSION"
exit 0
	}

	check_dependencies() {
		# Prevent bad system call error as non-root user
		print_not_root_user

		# Check for required dependencies
		for mis_dep in mkswap swapon swapoff dd df awk; do
			[[ ! $(type -p "$mis_dep") ]] && {
				print_missing_dependencies "$mis_dep"
			}
		done
	}

	multiple_instances() {
		[[ -f ${HOME:=/mnt}/.swap_running ]] && {
			print_error "Previous running instance of '$SCRIPT_NAME' detected"
			print_aligned "Exiting"
			exit 1
		}
	}

	check_free_storage() {
		# Workaround for missing `df -m` on Android
		free_storage="$(df -k "$storage_checker" 2>/dev/null | awk 'NR==2 {print $4}' 2>/dev/null)"
		free_storage="${free_storage//[A-Z]}"

		[[ $size_suffix =~ m|M|mb|mB|Mb|MB ]] && {
			size_check="$((user_value * 1024))"
		}

		[[ $size_suffix =~ g|G|gb|gB|Gb|GB ]] && {
			size_check="$((user_value * 1024 * 1024))"
		}

		[[ $free_storage -le $size_check ]] && {
			print_error "Cannot create '$file_name' swapfile: Insufficient storage"
			exit 1
		}
	}

	not_a_swapfile() {
		[[ ! -f $file_name ]] && {
			print_error "Cannot stat '$file_name': No such file or directory"
			exit 1
		}

		[[ $(< /proc/swaps) != *${file_name}* || ! -s $file_name ]] && {
			print_error "Cannot disable '$file_name': File is not a swapfile"
			exit 1
		}
	}

	create_swapfile() {
		# Input argument should follow the syntax
		# $SCRIPT_NAME --on 2048M ~/.local/share/swapfile0"
		[[ $# -lt 3 || $# -gt 3 ]] && {
			print_syntax_error
		}

		# Process user input and seperate characters from integers
		user_value="$2"
		user_value="${user_value//[aA-zZ]}"

		size_suffix="$2"
		size_suffix="${size_suffix//[0.0-9.90-9]}"

		# Check for invalid user input
		integer_checker="${user_value//[0.0-9.90-9]}"
		integer_checker="${integer_checker//[[:space:]]}"
		[[ -n $integer_checker || -z $user_value ]] && {
			print_error "Input swapfile size in MB or GB"
			print_aligned "Example: 5G, 10GB, 5120M, 10240MB"
			exit 1
		}

		# Declare user specified file name
		file_name="$3"

		# Check if a file exist with $file_name
		[[ -e $file_name ]] && {
			print_error "Cannot create '$file_name' swapfile: File exists"
			exit 1
		}

		# Declare file path
		# Downloads/user/new/ -> Downloads/user/new
		folder_name="${file_name%\/}"

		# Downloads/user/new -> Downloads/user
		folder_name="${folder_name%\/*}"

		# Use current directory if user only specified a file name
		[[ -z ${folder_name/*$file_name*} ]] && {
			folder_name="$PWD"
		}

		# Folder to check for disk space
		storage_checker="$folder_name"
		[[ ! -d $folder_name ]] && {
			storage_checker="$PWD"
		}

		# Check available device storage
		check_free_storage "$@"

		# Create destination directory
		mkdir -p "$folder_name" 2>/dev/null || print_write_error "$folder_name"

		# Create swapfile
		case "$size_suffix" in
			m | M | mb | mB | Mb | MB)
				[[ $user_value -lt 100 ]] && {
					print_error "${user_value}MB is too small for swapfile"
					exit 1
				}

				exit_status=0

				touch "${HOME:=/mnt}/.swap_running" 2>/dev/null

				print_warning "Creating ${user_value}MB swapfile"
				print_aligned "This may take a while"
				printf '\n'
				dd if=/dev/zero of="$file_name" bs=1M count="$user_value" &>/dev/null || exit_status=1
				chown root:root "$file_name" 2>/dev/null &&
				chmod 0600 "$file_name" 2>/dev/null &&
				mkswap "$file_name" &>/dev/null &&
				swapon "$file_name" &>/dev/null || exit_status=1
				size_suffix="MB"

				rm "${HOME:=/mnt}/.swap_running" 2>/dev/null

				[[ -n $exit_status && $exit_status -eq 0 ]] && {
					print_success "Finished creating ${user_value}${size_suffix} swapfile"
					exit 0
				}

				print_error "Something went wrong: Failed to create '$file_name' swapfile"

				rm -r "$file_name" 2>/dev/null
				exit 1
			;;
			g | G | gb | gB | Gb | GB)
				# Bash converts Floats to Integers
				[[ $user_value -le 0 ]] && {
					print_error "${user_value}GB is too small for swapfile"
					exit 1
				}

				exit_status=0

				touch "${HOME:=/mnt}/.swap_running" 2>/dev/null

				print_warning "Creating ${user_value}GB swapfile"
				print_aligned "This may take a while"
				printf '\n'
				dd if=/dev/zero of="$file_name" bs=1G count="$user_value" &>/dev/null || exit_status=1
				chown root:root "$file_name" 2>/dev/null &&
				chmod 0600 "$file_name" 2>/dev/null &&
				mkswap "$file_name" &>/dev/null &&
				swapon "$file_name" &>/dev/null || exit_status=1
				size_suffix="GB"

				rm "${HOME:=/mnt}/.swap_running" 2>/dev/null

				[[ -n $exit_status && $exit_status -eq 0 ]] && {
					print_success "Finished creating ${user_value}${size_suffix} swapfile"
					exit 0
				}

				print_error "Something went wrong: Failed to create '$file_name' swapfile"

				rm -r "$file_name" 2>/dev/null
				exit 1
			;;
			*)
				print_error "Input swapfile size in MB or GB"
				print_aligned "Example: 5G, 10GB, 5120M, 10240MB"
				exit 1
			;;
		esac
	}

	# Disable and delete swapfile
	delete_swapfile() {
		# Input argument should follow the syntax
		# $SCRIPT_NAME --off ~/.local/share/swapfile0"
		[[ $# -lt 2 || $# -gt 2 ]] && {
			print_syntax_error
		}

		# Declare user specified file name
		file_name="$2"

		touch "${HOME:=/mnt}/.swap_running" 2>/dev/null

		print_warning "Disabling '$file_name' swapfile"
		print_aligned "This may take a while"
		printf '\n'

		swapoff "$file_name" 2>/dev/null &&
		rm -r "$file_name" 2>/dev/null
		print_success "Finished disabling '$file_name' swapfile"
		rm "${HOME:=/mnt}/.swap_running" 2>/dev/null
		exit 0
	}

	check_input_option() {
		for primary_options in "${@:1}"; do
			case "$primary_options" in
				-d | --disable)
					# Check for multiple instances
					multiple_instances "$@"
					
					check_dependencies "$@"

					# Declare file name
					file_name="$2"

					# Check if file_name is valid
					not_a_swapfile "$@"

					# Check used swap space for the specified file
					used_swap="$(< /proc/swaps)"
					used_swap="${used_swap//*"$file_name"}"
					used_swap="$(printf '%s\n' "${used_swap//\/*}" | awk '{print $3}')"

					# /proc/swaps stores values in KB
					[[ $used_swap -gt 204796 ]] && {
						print_warning "Swapfile is currently in use: Disabling it might cause problems"
						printf '\n'
						read -rep "Do you want to proceed (y/n) " user_option
						case "$user_option" in
							 Y | y)
								printf '\n'
								delete_swapfile "$@"
							;;
							*)
								run_on_exit "$@"
							;;
						esac
					}

					delete_swapfile "$@"
				;;
				-e | --enable)
					# Check for multiple instances
					multiple_instances "$@"

					check_dependencies "$@"

					create_swapfile "$@"
				;;
				-h | --help)
					print_help
				;;
				-V | --version)
					print_version
				;;
				-*)
					[[ -z ${primary_options#*\-} || -z ${primary_options/\-\-*} ]] && {
						print_error "Unrecognized option '${primary_options}'"
						print_notification
					}

					print_error "Invalid option -- '${primary_options#*\-}'"
					print_notification
				;;
				*)
					for secondary_options in "${@:2}"; do
						case "$secondary_options" in
							-h | --help)
								print_help
							;;
						esac
					done
					print_syntax_error
				;;
			esac
		done
	}

	trap 'remove_file_on_exit "$file_name" "${HOME:=/mnt}/.swap_running"' 1 2 3 15
	print_no_argument "$@"
	check_input_option "$@"
	exit
}

#--------------------------------------------------------------
# Platform: chroot
# Dependencies: mkdir, cp
#--------------------------------------------------------------
terp-deploy() {
	print_help() {
echo -e "\033[1;97mNAME\033[00m
	$SCRIPT_NAME - chroot setup tool for android.

\033[1;97mSYNOPSIS\033[00m
	$SCRIPT_NAME [OPTION]

\033[1;97mDESCRIPTION\033[00m
	Post-install and post-mount setup tool for chroot images running on Android.
	This program was created for, and will only work for chroot images created using
	terp-install and terp-mount.

	\033[1;97m-h, --help\033[00m
		display this help message and exit.

	\033[1;97m-s, --setup\033[00m
		setup chroot after mounting. this option is run automatically by
		terp-mount and manual usage is restricted.

	\033[1;97m-i, --install\033[00m
		setup chroot image after installation with terp-install.

	\033[1;97m-V, --version\033[00m
		output version information and exit.

\033[1;97mAUTHOR\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.
	Written by Kolade Ayomide Olanrewaju.

\033[1;97mREPORTING BUGS\033[00m
	Create a new issue at <https://github.com/teth3r/tether/>.

\033[1;97mCOPYRIGHT\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.

tether $SCRIPT_VERSION"
exit 0
	}

	check_dependencies() {
		# Chroot environment check
		# Check if device is Android or device is a Linux desktop
		[[ -d /system/app || -d /sys/class/power_supply/BAT0 ]] ||

		# Check if device has a Snapdragon CPU and is an Android device
		[[ ! -d /sys/class/kgsl && ! -d /sys/class/power_supply/battery ]] ||

		# Check if device has a Mediatek CPU and is an Android device
		[[ ! -d /proc/gpufreq && ! -d /sys/class/power_supply/battery ]] && {
			print_os_error
		}

		source "/etc/os-release" 2>/dev/null
		source "/etc/terp-deploy.conf" 2>/dev/null

		[[ $PRETTY_NAME != "Void Linux" && $NAME != "Alpine Linux" ]] && print_os_error

		# Check for required dependencies
		for mis_dep in mkdir cp; do
			[[ ! $(type -p "$mis_dep") ]] && {
				print_missing_dependencies "$mis_dep"
			}
		done

		user_name="${SUDO_USER:=$USER}"
	}

	post_install_setup() {
		# Exit if vim and tmux are installed
		[[ $TERP_DEPLOY_INSTALL == "true" ]] || [[ $(type -p tmux) && $(type -p vim) ]] && {
			print_error "Chroot has already been setup"
			exit 1
		}

		# Handles void chroot
		[[ $PRETTY_NAME == "Void Linux" ]] && {
			# Check for required dependencies
			for mis_dep in ping xbps-install; do
				[[ ! $(type -p "$mis_dep") ]] && {
					print_missing_dependencies "$mis_dep"
				}
			done

			[[ $(ping -c2 voidlinux.org 2>/dev/null) ]] && {
				print_warning "Setting up voidlinux chroot"
				printf '\n'
				sudo xbps-install -Syu xbps void-repo-nonfree
				sudo xbps-install -Syu 7zip-unrar git rust cargo bc ldns man 7zip wget gcc bash-completion unzip bsdtar || exit 1
				sudo xbps-install -Syu || exit 1
				sudo xbps-reconfigure -f glibc-locales || exit 1
				sudo makewhatis /usr/share/man || exit 1
				sudo chmod 777 /tmp || exit 1

				sudo xbps-install -Syu vim tmux || exit 1

				# Set config true status
				printf '%s\n' "TERP_DEPLOY_INSTALL=\"true\"" | sudo tee -a /etc/terp-deploy.conf &>/dev/null
			}
		}

		# Handles alpine chroot
		[[ $NAME == "Alpine Linux" ]] && {
			# Check for required dependencies
			for mis_dep in ping apk; do
				[[ ! $(type -p "$mis_dep") ]] && {
					print_missing_dependencies "$mis_dep"
				}
			done

			[[ $(ping -c2 alpinelinux.org 2>/dev/null) ]] && {
				print_warning "Setting up alpinelinux chroot"
				printf '\n'
				sudo apk add -u apk-tools
				sudo apk update && sudo apk upgrade
				sudo apk add 7zip git rust cargo bc ldns wget gcc bash-completion unzip libarchive-tools || exit 1
				sudo chmod 777 /tmp || exit 1

				sudo apk add vim tmux || exit 1

				# Set config true status
				printf '%s\n' "TERP_DEPLOY_INSTALL=\"true\"" | sudo tee -a /etc/terp-deploy.conf &>/dev/null
			}
		}

		# Populate $PATH with tetherutils
		/bin/tether --silent "/home/${user_name}/.local/bin" &&

		# Create custom bashrc
		/bin/tether dotfiles --bashrc &>/dev/null

		# Create custom vimrc and colorscheme
		/bin/tether dotfiles --vimrc &>/dev/null
		sudo /bin/tether dotfiles --vim-color &>/dev/null

		# Create custom tmux.conf
		/bin/tether dotfiles --tmux &>/dev/null

		sudo ln -sf "/home/${user_name}/.bashrc" "/root" || exit 1
		sudo ln -sf "/home/${user_name}/.tmux.conf" "/root" &&
		sudo ln -sf "/home/${user_name}/.vimrc" "/root" &&

		mkdir -p "/home/${user_name}/.vim" &&
		printf '\n' &&
		print_success "Finished setting up chroot"
		print_aligned "Run 'source /home/${user_name}/.bashrc' to reload shell"
		printf '\n'
	}

	password_mismatch() {
		printf '\n'
		print_error "Failed to change '$*' user password"
		print_aligned "Passwords do not match"
		exit 1
	}

	post_boot_setup() {
		# Check if running as saved user
		[[ $(cat /etc/terp-username.conf 2>/dev/null) == "$USER" ]] && {
			print_error "Chroot has already been setup"
			 exit 1
		}

		source "/etc/profile" 2>/dev/null

		# Check if user account has been created before
		[[ ! -f /etc/terp-deploy.conf ]] || [[ $TERP_DEPLOY_SETUP != "true" ]] && {
			# Check for internet connectivity
			[[ ! $(ping -c4 voidlinux.org 2>/dev/null) ]] && {
				print_error "Failed to detect an internet connection"
				exit 1
			}

			# Create new user account
			print_warning "Creating new user account"
			printf '\n'

			source "/etc/profile"
			read -rep "Input new username: " user_name
			read -rep "Confirm new username: " user_name2

			[[ $user_name != "$user_name2" ]] && {
				printf '\n'
				print_error "Username does not match"
				exit 1
			}

			[[ -z $user_name || -z $user_name2 ]] && {
				printf '\n'
				print_error "Username string cannot be empty"
				exit 1
			}

			# Set default permissions on /
			chown root:root /
			chmod 755 /

			[[ $PRETTY_NAME == "Void Linux" ]] && {
				# Change default locale
				printf '%s\n' "LANG=en_US.UTF-8" > /etc/locale.conf
				sed -i 's/#en_US.UTF-8 UTF-8/en_US.UTF-8 UTF-8/' /etc/default/libc-locales

				# Add locale if it doesn't exist
				locale_file="$(< /etc/default/libc-locales)"
				[[ $locale_file != *en_US.UTF-8\ UTF-8* ]] && {
				    printf '%s\n' "en_US.UTF-8 UTF-8" >> /etc/default/libc-locales
				}

				# Create network groups and add user
				groupadd -g 3001 aid_net_bt_admin 2>/dev/null
				groupadd -g 3002 aid_net_bt 2>/dev/null
				groupadd -g 3003 aid_inet 2>/dev/null
				groupadd -g 3004 aid_net_raw 2>/dev/null
				groupadd -g 3005 aid_net_admin 2>/dev/null
				groupadd -g 3006 aid_net_bw_stats 2>/dev/null
				groupadd -g 3007 aid_net_bw_acct 2>/dev/null
				groupadd -g 3008 aid_net_bt_stack 2>/dev/null
				useradd -m -G wheel,floppy,dialout,audio,video,kvm,3001,3002,3003,3004,3005,3006,3007,3008 "$user_name" 2>/dev/null
			}

			[[ $NAME == "Alpine Linux" ]] && {
				# Create network groups and add user
				addgroup -g 3001 aid_net_bt_admin 2>/dev/null
				addgroup -g 3002 aid_net_bt 2>/dev/null
				addgroup -g 3003 aid_inet 2>/dev/null
				addgroup -g 3004 aid_net_raw 2>/dev/null
				addgroup -g 3005 aid_net_admin 2>/dev/null
				addgroup -g 3006 aid_net_bw_stats 2>/dev/null
				addgroup -g 3007 aid_net_bw_acct 2>/dev/null
				addgroup -g 3008 aid_net_bt_stack 2>/dev/null

				adduser -u 1000 "${user_name}" -D 2>/dev/null
				adduser "${user_name}" wheel 2>/dev/null
				adduser "${user_name}" floppy 2>/dev/null
				adduser "${user_name}" dialout 2>/dev/null
				adduser "${user_name}" audio 2>/dev/null
				adduser "${user_name}" video 2>/dev/null
				adduser "${user_name}" kvm 2>/dev/null
				adduser "${user_name}" aid_net_bt_admin 2>/dev/null
				adduser "${user_name}" aid_net_bt 2>/dev/null
				adduser "${user_name}" aid_inet 2>/dev/null 
				adduser "${user_name}" aid_net_raw 2>/dev/null
				adduser "${user_name}" aid_net_admin 2>/dev/null
				adduser "${user_name}" aid_net_bw_stats 2>/dev/null
				adduser "${user_name}" aid_net_bw_acct 2>/dev/null
				adduser "${user_name}" aid_net_bt_stack 2>/dev/null
			}

			printf '\n'

			# Create new user password
			print_warning "Set password for new user '$user_name'"
			printf '\n'
			passwd "$user_name" || password_mismatch "$user_name"
			printf '\n'

			# Change default root-user password
			print_warning "Change the default 'root' user password"
			printf '\n'
			passwd root || password_mismatch "root"

			# Adds missing zoneinfo, resolv.conf and sudoers files
			[[ $NAME == "Alpine Linux" ]] && apk add tzdata sudo openresolv &>/dev/null
			
			# Add new user to sudoers file
			sed -i 's/# %wheel ALL=(ALL:ALL) ALL/%wheel ALL=(ALL:ALL) ALL/' /etc/sudoers

			# Save username for later logins
			printf '%s\n' "$user_name" > /etc/terp-username.conf

			# Set DNS server
			printf '%s\n' "nameserver 127.0.0.1" > /etc/resolv.conf
			chattr +i /etc/resolv.conf

			printf '\n'
			print_warning "Changing default timezone"
			printf '\n'

			# Change default time zone
			change_timezone "$@"

			print_success "Done, switching to new user '$user_name'"
			print_aligned "Run '$SCRIPT_NAME --install' to finish setting up chroot"
			printf '\n'

			# Change permissions of mounted dnscrypt files
			[[ -f "/mnt/module-dnscrypt/dnscrypt-proxy.toml" ]] && {
				chmod 666 /mnt/module-dnscrypt/*
			}

			# Set config true status
			printf '%s\n' "TERP_DEPLOY_SETUP=\"true\"" > /etc/terp-deploy.conf

			# Switch to new_user
			su "$user_name" -s /bin/bash && source "/etc/profile"
			exit 0
		}

		[[ -f "/mnt/module-dnscrypt/dnscrypt-proxy.toml" ]] && {
			chmod 666 /mnt/module-dnscrypt/*
		}

		[[ ! -f /etc/terp-username.conf ]] && {
			print_error "Cannot stat '/etc/terp-username.conf': No such file or directory"
			exit 1
		}

		# Read in saved username
		user_name="$(< /etc/terp-username.conf)"

		# Switch to saved user
		su "$user_name" -s /bin/bash && source "/etc/profile"
		exit 0
	}

	check_input_option() {
		for primary_options in "${@:1}"; do
			case "$primary_options" in
				-h | --help)
					print_help
				;;
				-i | --install)
					check_dependencies "$@"
					post_install_setup "$@"
				;;
				-s | --setup)
					check_dependencies "$@"
					post_boot_setup "$@"
				;;
				-V | --version)
					print_version
				;;
				-*)
					[[ -z ${primary_options#*\-} || -z ${primary_options/\-\-*} ]] && {
						print_error "Unrecognized option '${primary_options}'"
						print_notification
					}

					print_error "Invalid option -- '${primary_options#*\-}'"
					print_notification
				;;
				*)
					print_error "Unrecognized option '${primary_options}'"
					print_notification
				;;
			esac
		done
	}

	trap 'run_on_exit' 1 2 3 15
	print_no_argument "$@"
	check_input_option "$@"
	exit
}

#--------------------------------------------------------------
# Platform: Android
# Dependencies: mount, losetup, busybox, lsof, fallocate, mke2fs, sed
#--------------------------------------------------------------
terp-install() {
	print_help() {
echo -e "\033[1;97mNAME\033[00m
	$SCRIPT_NAME - chroot installation tool for android.

\033[1;97mSYNOPSIS\033[00m
	$SCRIPT_NAME [OPTION]

\033[1;97mDESCRIPTION\033[00m
	Chroot image creation tool for Android. This program downloads and
	extracts the rootfs file of the specifed linux distribution into an
	image file. The image file is portable and can be transferred between
	devices. This program only supports ARM64 rootfs files and Alpine Linux
	and Void Linux are the only supported Linux distributions.

	\033[1;97m-a, --alpine\033[00m
		download and install alpine linux rootfs.

	\033[1;97m-h, --help\033[00m
		display this help message and exit.

	\033[1;97m-V, --version\033[00m
		output version information and exit.

	\033[1;97m-v, --void\033[00m
		download and install void linux rootfs.

\033[1;97mAUTHOR\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.
	Written by Kolade Ayomide Olanrewaju.

\033[1;97mREPORTING BUGS\033[00m
	Create a new issue at <https://github.com/teth3r/tether/>.

\033[1;97mCOPYRIGHT\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.

tether $SCRIPT_VERSION"
exit 0
	}

	check_dependencies() {
		# Only run on Android
		[[ ! -d /system/app ]] && print_os_error

		# Run only on arm64 Android
		[[ $HOSTTYPE != aarch64 ]] && {
			print_os_error
		}

		# Check for required dependencies
		for mis_dep in mount losetup busybox lsof fallocate mke2fs sed; do
			[[ ! $(type -p "$mis_dep") ]] && {
				print_missing_dependencies "$mis_dep"
			}
		done

		# Only run as root-user
		print_not_root_user

		# Declare directories for void linux
		[[ $terp_flavor == "void" ]] && {
			chroot_image="/data/voidimg/void.img"
			chroot_image_dir="/data/voidimg"
			chroot_install_dir="/data/voidlinux"
			# Let device handle loop devices
			block_device="$(losetup -f 2>/dev/null)"
		}

		# Declare directories for alpine linux
		[[ $terp_flavor == "alpine" ]] && {
			chroot_image="/data/alpineimg/alpine.img"
			chroot_image_dir="/data/alpineimg"
			chroot_install_dir="/data/alpinelinux"
			# Let device handle loop devices
			block_device="$(losetup -f 2>/dev/null)"
		}

		# Declare directories common to both variants
		tmp_dir="/data/local/tmp"
		module_dns="$MODULE_DIRECTORY/system/etc/dnscrypt-proxy"
		current_dir="$PWD"

		[[ -f "$chroot_install_dir/bin/bash" || -f $chroot_image || $(lsof "$chroot_install_dir" 2>/dev/null) ]] && {
			print_error "Chroot is already installed"
			print_aligned "Run 'terp-mount --${terp_flavor}' to initialize it"
			exit 1
		}

		mkdir -p "$tmp_dir" 2>/dev/null || print_write_error "$tmp_dir"

		# Check for internet connectivity
		[[ ! $(ping -c4 voidlinux.org 2>/dev/null) ]] && {
			print_error "Failed to detect an internet connection"
			exit 1
		}
	}

	download_fail() {
		print_error "Something went wrong"
		print_aligned "Failed to download '$rootfs_file'"
		rm -r "${tmp_dir:=/data/local/tmp}/${rootfs_file}" "${tmp_dir:=/data/local/tmp}/sha256sum.txt" 2>/dev/null
		exit 1
	}

	download_fail_shasum() {
		print_error "Something went wrong"
		print_aligned "Failed to download 'sha256sum.txt'"
		rm -r "${tmp_dir:=/data/local/tmp}/sha256sum.txt" 2>/dev/null
		exit 1
	}

	check_file_hash() {
		# Get file hashsum
		downloaded_file_hash="$(busybox sha256sum "${tmp_dir}"/"${rootfs_file}")"
		downloaded_file_hash="${downloaded_file_hash//\ *}"
		downloaded_file_hash="${downloaded_file_hash//[[:space:]]}"

		# Get file hash
		[[ $terp_flavor == "void" ]] && {
			shasum_file_hash="$(< "$tmp_dir"/sha256sum.txt)"
			shasum_file_hash="${shasum_file_hash//*"$rootfs_file"}"
			shasum_file_hash="${shasum_file_hash//SHA256*}"
			shasum_file_hash="${shasum_file_hash//*\ }"
			shasum_file_hash="${shasum_file_hash//[[:space:]]}"
		}

		[[ $terp_flavor == "alpine" ]] && {
			shasum_file_hash="$(< "$tmp_dir"/sha256sum.txt)"
			shasum_file_hash="${shasum_file_hash//\ *}"
			shasum_file_hash="${shasum_file_hash//[[:space:]]}"
		}

		# Compare file hashes
		[[ $downloaded_file_hash != "$shasum_file_hash" ]] && {
			print_error "Hash mismatch, possible MITM attack"
			print_aligned "Try again at a later time"
			rm -r "${tmp_dir:=/data/local/tmp}/${rootfs_file}" "${tmp_dir:=/data/local/tmp}/sha256sum.txt" 2>/dev/null
			exit 1
		}
	}

	fetch_rootfs() {
		print_warning "Downloading 'sha256sum.txt'"
		printf '\n'

		[[ $terp_flavor == "void" ]] && {
			shasum_file="https://repo-default.voidlinux.org/live/current/sha256sum.txt"

			# Download sha256sum.txt
			busybox wget "$shasum_file" -O "$tmp_dir/sha256sum.txt" &>/dev/null ||

			# Error handling on download failure
			download_fail_shasum "$@"

			# Get latest aarch64 rootfs filename
			rootfs_version="$(< "$tmp_dir"/sha256sum.txt)"
			rootfs_version=${rootfs_version//*void-aarch64-ROOTFS}
			rootfs_version=${rootfs_version//\)*}
			rootfs_version=${rootfs_version//[[:space:]]}

			# Set download link for rootfs
			rootfs_version="https://repo-default.voidlinux.org/live/current/void-aarch64-ROOTFS${rootfs_version}"
		}

		[[ $terp_flavor == "alpine" ]] && {
			# Since alpine is not a rolling release distro -- this url will need to be updated for future releases
			shasum_file="https://dl-cdn.alpinelinux.org/alpine/v3.19/releases/aarch64/alpine-minirootfs-3.19.1-aarch64.tar.gz.sha256"

			# Download sha256sum.txt
			busybox wget "$shasum_file" -O "$tmp_dir/sha256sum.txt" &>/dev/null ||

			# Error handling on download failure
			download_fail_shasum "$@"

			# Get latest aarch64 rootfs filename
			rootfs_version="$(< "$tmp_dir"/sha256sum.txt)"
			rootfs_version=${rootfs_version//*\ }
			rootfs_version=${rootfs_version//[[:space:]]}

			# Set download link for rootfs
			rootfs_version="https://dl-cdn.alpinelinux.org/alpine/v3.19/releases/aarch64/${rootfs_version}"
		}

		# Set downloaded file name
		rootfs_file="${rootfs_version//*\/}"

		print_warning "Downloading '$rootfs_file'"
		print_aligned "This may take a while"
		printf '\n'

		# Download latest available rootfs
		busybox wget "$rootfs_version" -O "${tmp_dir}/${rootfs_file}" &>/dev/null ||

		# Error handling on download failure
		download_fail "$@"
		print_warning "Comparing file hashes"
		printf '\n'

		# Check downloaded file hashsum
		check_file_hash "$@"
	}

	install_preparation() {
		# Check if rootfs has already been downloaded
		[[ -f ${tmp_dir}/sha256sum.txt ]] && {
			# Get rootfs filename
			[[ $terp_flavor == "alpine" ]] && {
				rootfs_version="$(< "$tmp_dir"/sha256sum.txt)"
				rootfs_version=${rootfs_version//*\ }
				rootfs_version=${rootfs_version//[[:space:]]}
				rootfs_file="${rootfs_version}"
			}

			[[ $terp_flavor == "void" ]] && {
				rootfs_version="$(< "$tmp_dir"/sha256sum.txt)"
				rootfs_version=${rootfs_version//*void-aarch64-ROOTFS}
				rootfs_version=${rootfs_version//\)*}
				rootfs_version=${rootfs_version//[[:space:]]}
				rootfs_file="void-aarch64-ROOTFS${rootfs_version}"
			}

			# Check file hash if rootfs exists
			[[ -f ${tmp_dir}/${rootfs_file} ]] && {
				print_warning "Comparing file hashes"
				printf '\n'
				check_file_hash "$@"
			}

			# Download rootfs if it doesn't exist
			[[ ! -f ${tmp_dir}/${rootfs_file} ]] && {
				fetch_rootfs "$@"
			}
		}

		[[ ! -f ${tmp_dir}/sha256sum.txt ]] && {
			# Download rootfs
			fetch_rootfs "$@"
		}

		# rootfs file path
		downloaded_rootfs="${tmp_dir}/${rootfs_file}"

		# Extracted rootfs
		# alpine-minirootfs-3.19.1-aarch64.tar.gz -> alpine-minirootfs-3.19.1-aarch64.tar
		extracted_file="${rootfs_file%.*}"

		# Check if rootfs exists
		[[ ! -f $downloaded_rootfs ]] && {
			print_error "'$rootfs_file' not found"
			exit 1
		}

		# Set size of chroot image
		print_warning "Preparing install location"
		printf '\n'
		cd "$PHONE_STORAGE" 2>/dev/null || print_dir_change_error "${PHONE_STORAGE}"
		rm -r "$chroot_image" 2>/dev/null
		rm -r "$chroot_install_dir" 2>/dev/null

		# Process user input
		read -rep "Input desired size of chroot image: " input_size
		printf '\n'

		# Process user input and seperate characters from integers
		user_value="$input_size"
		user_value="${user_value//[aA-zZ]}"
		size_suffix="$input_size"
		size_suffix="${size_suffix//[0.0-9.90-9]}"

		# Check for invalid input
		integer_checker="${user_value//[0.0-9.90-9]}"
		integer_checker="${integer_checker//[[:space:]]}"
		[[ -n $integer_checker || -z $user_value ]] && {
			print_error "Input chroot size in MB or GB"
			print_aligned "Example: 5G, 10GB, 5120M, 10240MB"
			exit 1
		}

		# Create chroot install directories
		mkdir -p "$chroot_install_dir" || print_write_error "$chroot_install_dir"
		mkdir -p "$chroot_image_dir" || print_write_error "$chroot_image_dir"
	}

	create_image() {
		# Download and confirm rootfs file hashsum
		install_preparation "$@"

		# Create chroot container
		case "$size_suffix" in
			m | M | mb | mB | Mb | MB)
				[[ $user_value -lt 2048 ]] && {
					print_error "${user_value}MB is too small for chroot"
					print_aligned "You need at least 2048MB"
					exit 1
				}

				print_warning "Creating ${user_value}MB image file"
				printf '\n'
				fallocate -l "${user_value}"M "$chroot_image"
				size_suffix="MB"
			;;
			g | G | gb | gB | Gb | GB)
				[[ $user_value -lt 2 ]] && {
					print_error "${user_value}GB is too small for chroot"
					print_aligned "You need at least 2GB"
					exit 1
				}

				print_warning "Creating ${user_value}GB image file"
				printf '\n'
				fallocate -l "${user_value}"G "$chroot_image"
				size_suffix="GB"
			;;
			*)
				print_error "Input chroot size in MB or GB"
				print_aligned "Example: 5G, 10GB, 5120M, 10240MB"
				exit 1
			;;
		esac
	}

	loop_device_active() {
		print_error "'$block_device' is already in use"
		exit 1
	}
	
	chroot_installation() {
		# Create chroot container
		create_image "$@"

		# Extract rootfs in chroot container
		[[ -f $chroot_image ]] && {
			mke2fs -t ext4 "$chroot_image" &>/dev/null
			losetup "$block_device" "$chroot_image" 2>/dev/null || loop_device_active "$@"
			mount -t ext4 "$block_device" "$chroot_install_dir"

			cp "$downloaded_rootfs" "$chroot_install_dir"
			cd "$chroot_install_dir" 2>/dev/null || print_dir_change_error "${chroot_install_dir}"

			print_warning "Extracting '$rootfs_file'"
			printf '\n'

			[[ $terp_flavor == "void" ]] && {
				busybox xz -d "${downloaded_rootfs##*/}" &>/dev/null
				busybox tar -xf "$extracted_file" &>/dev/null && rm "$extracted_file"
			}

			[[ $terp_flavor == "alpine" ]] && {
				busybox gzip -d "${downloaded_rootfs##*/}" &>/dev/null
				busybox tar -xf "$extracted_file" &>/dev/null && rm "$extracted_file"
			}

			mount -t proc /proc "$chroot_install_dir/proc/"
			mount -t sysfs /sys "$chroot_install_dir/sys/"
			mount -o bind /dev "$chroot_install_dir/dev/"
			mount -o bind /dev/pts "$chroot_install_dir/dev/pts/"

			mkdir -p "$chroot_install_dir/mnt/sdcard"
			mount "$PHONE_STORAGE" "$chroot_install_dir/mnt/sdcard"

			# Incase there are no dnscrypt-proxy files
			[[ -f $module_dns/dnscrypt-proxy.toml ]] && {
				mkdir -p "$chroot_install_dir/mnt/module-dnscrypt"
				mount "$module_dns" "$chroot_install_dir/mnt/module-dnscrypt"
			}

			# Incase there's no external storage
			[[ -n $EXTERNAL_STORAGE ]] && {
				mount "$EXTERNAL_STORAGE" "$chroot_install_dir/media"
			}

			# Get ${0:=SCRIPT_NAME} file path
			# Handles ./${SCRIPT_NAME}
			[[ -f ${0#\.\/} ]] && {
				cp -f "${0#\.\/}" "$chroot_install_dir/bin/tether"
				cp -f "${0#\.\/}" "$chroot_install_dir/bin/terp-deploy"
			}

			# Handles ./<dirname>/${SCRIPT_NAME}
			[[ -f ${0#\.} ]] && {
				cp -f "${0#\.}" "$chroot_install_dir/bin/tether"
				cp -f "${0#\.}" "$chroot_install_dir/bin/terp-deploy"
			}

			# Create symlink for /bin/env
			[[ $terp_flavor == "alpine" ]] && {
				sed -i 's|#!/bin/env bash|#!/bin/bash|' "$chroot_install_dir/bin/tether" 2>/dev/null
				sed -i 's|#!/bin/env bash|#!/bin/bash|' "$chroot_install_dir/bin/terp-deploy" 2>/dev/null
				chroot "$chroot_install_dir" apk add bash &>/dev/null
			}

			print_success "Finished installing ${user_value}${size_suffix} chroot"
			print_aligned "Run 'terp-mount --${terp_flavor}' to initialize it"

			# Clean up files on finish
			rm -r "${tmp_dir:=/data/local/tmp}/${rootfs_file}" "${tmp_dir:=/data/local/tmp}/sha256sum.txt" 2>/dev/null
			cd "$current_dir" 2>/dev/null || print_dir_change_error "${current_dir}"
			exit 0
		}

		[[ ! -f $chroot_image ]] && {
			print_error "Chroot image not detected"
			print_aligned "Run 'terp-install --${terp_flavor}' before proceeding"
			rm -r "${tmp_dir:=/data/local/tmp}/${rootfs_file}" "${tmp_dir:=/data/local/tmp}/sha256sum.txt" 2>/dev/null
			exit 1
		}
	}

	check_input_option() {
		for primary_options in "${@:1}"; do
			case "$primary_options" in
				-a | --alpine)
					[[ $# -ne 1 ]] && print_syntax_error "$@"

					terp_flavor="alpine"
					check_dependencies "$@"
					chroot_installation "$@"
				;;
				-h | --help)
					print_help
				;;
				-V | --version)
					print_version
				;;
				-v | --void)
					[[ $# -ne 1 ]] && print_syntax_error "$@"

					terp_flavor="void"
					check_dependencies "$@"
					chroot_installation "$@"
				;;
				-*)
					[[ -z ${primary_options#*\-} || -z ${primary_options/\-\-*} ]] && {
						print_error "Unrecognized option '${primary_options}'"
						print_notification
					}

					print_error "Invalid option -- '${primary_options#*\-}'"
					print_notification
				;;
				*)
					print_error "Unrecognized option '${primary_options}'"
					print_notification
				;;
			esac
		done
	}

	trap 'remove_file_on_exit "${tmp_dir:=/data/local/tmp}/${rootfs_file}" "${tmp_dir:=/data/local/tmp}/sha256sum.txt"' 1 2 3 15
	print_no_argument "$@"
	check_input_option "$@"
	exit
}

#--------------------------------------------------------------
# Platform: Android
# Dependencies: losetup, mount, mkdir, sed
#--------------------------------------------------------------
terp-mount() {
	print_help() {
echo -e "\033[1;97mNAME\033[00m
	$SCRIPT_NAME - chroot initialization tool for android.

\033[1;97mSYNOPSIS\033[00m
	$SCRIPT_NAME [OPTION]

\033[1;97mDESCRIPTION\033[00m
	Mount tool for chroot images running on Android. This program was created
	for, and will only work for chroot images created using terp-install.

	\033[1;97m-a, --alpine\033[00m
		mount alpine linux chroot image.

	\033[1;97m-h, --help\033[00m
		display this help message and exit.

	\033[1;97m-V, --version\033[00m
		output version information and exit.

	\033[1;97m-v, --void\033[00m
		mount void linux chroot image.


\033[1;97mAUTHOR\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.
	Written by Kolade Ayomide Olanrewaju.

\033[1;97mREPORTING BUGS\033[00m
	Create a new issue at <https://github.com/teth3r/tether/>.

\033[1;97mCOPYRIGHT\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.

tether $SCRIPT_VERSION"
exit 0
	}

	check_dependencies() {
		# Only run on Android
		[[ ! -d /system/app/ || ! -f /system/build.prop ]] && {
			print_os_error
		}

		# Check for required dependencies
		for mis_dep in losetup mount mkdir sed; do
			[[ ! $(type -p "$mis_dep") ]] && {
				print_missing_dependencies "$mis_dep"
			}
		done

		# Only run as root user
		print_not_root_user

		# Declare directories for void linux
		[[ $terp_flavor == "void" ]] && {
			chroot_image="/data/voidimg/void.img"
			chroot_install_dir="/data/voidlinux"
			# Let device handle loop devices
			block_device="$(losetup -j "$chroot_image" 2>/dev/null)"
			block_device="${block_device/*\(}"
			block_device="${block_device/\)*}"
			# Use free loop device if one isn't already in use
			[[ -z $block_device ]] && {
				block_device="$(losetup -f 2>/dev/null)"
			}
		}

		# Declare directories for alpine linux
		[[ $terp_flavor == "alpine" ]] && {
			chroot_image="/data/alpineimg/alpine.img"
			chroot_install_dir="/data/alpinelinux"
			# Let device handle loop devices
			block_device="$(losetup -j "$chroot_image" 2>/dev/null)"
			block_device="${block_device/*\(}"
			block_device="${block_device/\)*}"
			# Use free loop device if one isn't already in use
			[[ -z $block_device ]] && {
				block_device="$(losetup -f 2>/dev/null)"
			}
		}

		# Declare directories common to both variants
		module_dns="$MODULE_DIRECTORY/system/etc/dnscrypt-proxy"

		# Check if chroot file exists
		[[ ! -f $chroot_image ]] && {
			print_error "Chroot not detected"
			print_aligned "Run 'terp-install --${terp_flavor}' before proceeding"
			exit 1
		}

		# Create chroot container mount directory
		[[ ! -d $chroot_install_dir ]] && {
			mkdir -p "$chroot_install_dir" 2>/dev/null
		}
	}

	loop_device_active() {
		print_error "'$block_device' is already in use"
		exit 1
	}
	
	chroot_mount() {
		mount -t ext4 "$block_device" "$chroot_install_dir"
		mount -t proc /proc "$chroot_install_dir/proc/"
		mount -t sysfs /sys "$chroot_install_dir/sys/"
		mount -o bind /dev "$chroot_install_dir/dev/"
		mount -o bind /dev/pts "$chroot_install_dir/dev/pts/"

		mkdir -p "$chroot_install_dir/mnt/sdcard"
		mount "$PHONE_STORAGE" "$chroot_install_dir/mnt/sdcard"

		# Incase there are no dnscrypt-proxy files
		[[ -f $module_dns/dnscrypt-proxy.toml ]] && {
			mkdir -p "$chroot_install_dir/mnt/module-dnscrypt"
			mount "$module_dns" "$chroot_install_dir/mnt/module-dnscrypt"
		}

		# Incase there's no external storage
		[[ -n $EXTERNAL_STORAGE ]] && {
			mount "$EXTERNAL_STORAGE" "$chroot_install_dir/media"
		}

		# Get ${0:=SCRIPT_NAME} file path
		# Handles ./${SCRIPT_NAME}
		[[ -f ${0#\.\/} ]] && {
			cp -f "${0#\.\/}" "$chroot_install_dir/bin/tether"
			cp -f "${0#\.\/}" "$chroot_install_dir/bin/terp-deploy"
		}

		# Handles ./<dirname>/${SCRIPT_NAME}
		[[ -f ${0#\.} ]] && {
			cp -f "${0#\.}" "$chroot_install_dir/bin/tether"
			cp -f "${0#\.}" "$chroot_install_dir/bin/terp-deploy"
		}

		# Create symlink for /bin/env
		[[ $terp_flavor == "alpine" ]] && {
			sed -i 's|#!/bin/env bash|#!/bin/bash|' "$chroot_install_dir/bin/tether" 2>/dev/null
			sed -i 's|#!/bin/env bash|#!/bin/bash|' "$chroot_install_dir/bin/terp-deploy" 2>/dev/null
		}

		chroot "$chroot_install_dir" /bin/bash -l /bin/terp-deploy --setup
		exit 0
	}

	chroot_mount_main() {
		# Handles unmounted chroot container and inactive block device
		[[ ! $(losetup -j "$chroot_image") ]] && {
			losetup "$block_device" "$chroot_image" 2>/dev/null || loop_device_active "$@"
			chroot_mount "$@"
		}

		# Handles active block device but unmounted chroot container
		[[ ! -f "$chroot_install_dir/bin/dmesg" ]] && {
			chroot_mount "$@"
		}

		# Handles mounted chroot container and active block device
		# Handles ./${SCRIPT_NAME}
		[[ -f ${0#\.\/} ]] && {
			cp -f "${0#\.\/}" "$chroot_install_dir/bin/tether"
			cp -f "${0#\.\/}" "$chroot_install_dir/bin/terp-deploy"
		}

		# Handles ./<dirname>/${SCRIPT_NAME}
		[[ -f ${0#\.} ]] && {
			cp -f "${0#\.}" "$chroot_install_dir/bin/tether"
			cp -f "${0#\.}" "$chroot_install_dir/bin/terp-deploy"
		}

		# Create symlink for /bin/env
		[[ $terp_flavor == "alpine" ]] && {
			sed -i 's|#!/bin/env bash|#!/bin/bash|' "$chroot_install_dir/bin/tether" 2>/dev/null
			sed -i 's|#!/bin/env bash|#!/bin/bash|' "$chroot_install_dir/bin/terp-deploy" 2>/dev/null
		}

		chroot "$chroot_install_dir" /bin/bash -l /bin/terp-deploy --setup
		exit 0
	}

	check_input_option() {
		for primary_options in "${@:1}"; do
			case "$primary_options" in
				-a | --alpine)
					[[ $# -ne 1 ]] && print_syntax_error "$@"

					terp_flavor="alpine"
					check_dependencies "$@"
					chroot_mount_main "$@"
				;;
				-h | --help)
					print_help
				;;
				-V | --version)
					print_version
				;;
				-v | --void)
					[[ $# -ne 1 ]] && print_syntax_error "$@"

					terp_flavor="void"
					check_dependencies "$@"
					chroot_mount_main "$@"
				;;
				-*)
					[[ -z ${primary_options#*\-} || -z ${primary_options/\-\-*} ]] && {
						print_error "Unrecognized option '${primary_options}'"
						print_notification
					}

					print_error "Invalid option -- '${primary_options#*\-}'"
					print_notification
				;;
				*)
					print_error "Unrecognized option '${primary_options}'"
					print_notification
				;;
			esac
		done
	}

	trap 'run_on_exit' 1 2 3 15
	print_no_argument "$@"
	check_input_option "$@"
	input_option_type_two "$@"
	exit
}

#--------------------------------------------------------------
# Platform: Android
# Dependencies: losetup, umount, lsof, wc, rm
#--------------------------------------------------------------
terp-umount() {
	print_help() {
echo -e "\033[1;97mNAME\033[00m
	$SCRIPT_NAME - chroot unmount tool for android.

\033[1;97mSYNOPSIS\033[00m
	$SCRIPT_NAME [OPTION]

\033[1;97mDESCRIPTION\033[00m
	Unmount tool for chroot images running on Android. This program was
	created for, and will only work for chroot images created using terp-install.

	\033[1;97m-a, --alpine\033[00m
		umount alpine linux chroot image.

	\033[1;97m-h, --help\033[00m
		display this help message and exit.

	\033[1;97m-V, --version\033[00m
		output version information and exit.

	\033[1;97m-v, --void\033[00m
		umount void linux chroot image.


\033[1;97mAUTHOR\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.
	Written by Kolade Ayomide Olanrewaju.

\033[1;97mREPORTING BUGS\033[00m
	Create a new issue at <https://github.com/teth3r/tether/>.

\033[1;97mCOPYRIGHT\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.

tether $SCRIPT_VERSION"
exit 0
	}

	check_dependencies() {
		# Only run on Android
		[[ ! -d /system/app/ || ! -f /system/build.prop ]] && {
			print_os_error
		}

		# Check for required dependencies
		for mis_dep in losetup umount lsof wc mkdir rm; do
			[[ ! $(type -p "$mis_dep") ]] && {
				print_missing_dependencies "$mis_dep"
			}
		done

		# Only run as root user
		print_not_root_user

		# Declare directories for void linux
		[[ $terp_flavor == "void" ]] && {
			chroot_image="/data/voidimg/void.img"
			chroot_install_dir="/data/voidlinux"
			# Let device handle loop devices
			block_device="$(losetup -j "$chroot_image" 2>/dev/null)"
			block_device="${block_device/*\(}"
			block_device="${block_device/\)*}"
		}

		# Declare directories for alpine linux
		[[ $terp_flavor == "alpine" ]] && {
			chroot_image="/data/alpineimg/alpine.img"
			chroot_install_dir="/data/alpinelinux"
			# Let device handle loop devices
			block_device="$(losetup -j "$chroot_image" 2>/dev/null)"
			block_device="${block_device/*\(}"
			block_device="${block_device/\)*}"
		}

		# Check if chroot file exists
		[[ ! -f $chroot_image ]] && {
			print_error "Chroot not detected"
			print_aligned "Run 'terp-install --${terp_flavor}' before proceeding"
			[[ -d $chroot_install_dir ]] && {
				rm -r "${chroot_image%/*}" 2>/dev/null
				rm -r "$chroot_install_dir" 2>/dev/null
			}
			exit 1
		}

		# Create chroot container mount directory
		[[ ! -d $chroot_install_dir ]] && {
			mkdir -p "$chroot_install_dir" 2>/dev/null
		}

		# Check if running through adb
		[[ -n $ANDROID_SOCKET_adbd ]] && {
			print_error "Cannot unmount chroot: adb socket detected"
			print_aligned "Unmounting through adb is not supported"
			exit 1
		}

		# Check if chroot has any running processes
		[[ $(lsof "$chroot_install_dir" 2>/dev/null) ]] && {
			print_error "Cannot unmount chroot: ($(lsof "$chroot_install_dir" | wc -l)) Running processes detected"
			exit 1
		}
	}

	failed_delete() {
		print_error "Something went wrong"
		print_aligned "Failed to remove chroot"
		exit 1
	}

	unmount_chroot() {
		# Handles mounted chroot container with no running processes
		[[ -f "$chroot_install_dir/bin/dmesg" || -d "$chroot_install_dir/mnt/sdcard" ]] && {
			cd "$PHONE_STORAGE" 2>/dev/null || print_dir_change_error "${PHONE_STORAGE}"
			umount "$chroot_install_dir/proc" 2>/dev/null
			umount "$chroot_install_dir/sys" 2>/dev/null
			umount -lf "$chroot_install_dir/dev/pts" 2>/dev/null
			umount -lf "$chroot_install_dir/dev" 2>/dev/null
			umount "$chroot_install_dir/mnt/sdcard" 2>/dev/null

			# Incase there are no dnscrypt-proxy files
			umount "$chroot_install_dir/mnt/module-dnscrypt" 2>/dev/null

			# Incase there's no external storage
			umount "$chroot_install_dir/media" 2>/dev/null
			umount -lf "$chroot_install_dir" 2>/dev/null
			losetup -d "$block_device" 2>/dev/null

			[[ $(losetup -j "$chroot_image") ]] && {
				print_error "Failed to unmount chroot"
				exit 1
			}

			print_success "Unmounted chroot"
			exit 0
		}

		# Handles unmounted chroot container and active block device
		[[ $(losetup -j "$chroot_image") ]] && {
			losetup -d "$block_device" 2>/dev/null

			[[ $(losetup -j "$chroot_image") ]] && {
				print_error "Failed to unmount chroot"
				exit 1
			}

			print_success "Unmounted chroot"
			exit 0
		}

		# Handles unmounted chroot container and inactive block device
		print_error "Chroot not mounted"
		exit 1
	}

	remove_chroot() {
		print_warning "This action is irreversible"
		printf '\n'
		read -rep "Do you want to proceed (y/n) " option_args
		case "$option_args" in
			y | Y)
				printf '\n'
				# Handles mounted chroot container with no running processes
				[[ -f "$chroot_install_dir/bin/dmesg" || -d "$chroot_install_dir/mnt/sdcard" ]] && {
					cd "$PHONE_STORAGE" 2>/dev/null || print_dir_change_error "${PHONE_STORAGE}"
					umount "$chroot_install_dir/proc" 2>/dev/null
					umount "$chroot_install_dir/sys" 2>/dev/null
					umount -lf "$chroot_install_dir/dev/pts" 2>/dev/null
					umount -lf "$chroot_install_dir/dev" 2>/dev/null
					umount "$chroot_install_dir/mnt/sdcard" 2>/dev/null

					# Incase there are no dnscrypt-proxy files
					umount "$chroot_install_dir/mnt/module-dnscrypt" 2>/dev/null

					# Incase there's no external storage
					umount "$chroot_install_dir/media" 2>/dev/null
					umount -lf "$chroot_install_dir" 2>/dev/null
					losetup -d "$block_device" 2>/dev/null

					[[ $(losetup -j "$chroot_image") ]] && {
						print_error "Failed to unmount chroot"
						exit 1
					}
				}

				# Handles unmounted chroot container and active block device
				[[ $(losetup -j "$chroot_image") ]] && {
					losetup -d "$block_device" 2>/dev/null

					[[ $(losetup -j "$chroot_image") ]] && {
						print_error "Failed to unmount chroot"
						exit 1
					}
				}

				unset exit_status
				rm -r "${chroot_image%/*}" &&
				rm -r "$chroot_install_dir" &&
				exit_status=0

				[[ -n $exit_status && $exit_status -eq 0 ]] && {
					print_success "Removed chroot"
					exit 0
				}

				failed_delete "$@"
			;;
			n | N)
				printf '\n'
				print_error "Aborted"
				exit 1
			;;
			 *)
				printf '\n'
				print_error "Unrecognized option '$option_args'"
				exit 1
			;;
		esac
	}

	check_input_option() {
		for primary_options in "${@:1}"; do
			case "$primary_options" in
				-a | --alpine)
					[[ $# -ne 1 ]] && print_syntax_error "$@"

					terp_flavor="alpine"
					check_dependencies "$@"
					unmount_chroot "$@"
				;;
				-h | --help)
					print_help
				;;
				-r | --remove)
					[[ $# -ne 2 ]] && print_syntax_error "$@"

					for flavor in "${@:1}"; do
						[[ $flavor == "void" ]] && terp_flavor="void"
						[[ $flavor == "alpine" ]] && terp_flavor="alpine"
					done

					[[ $terp_flavor != "void" && $terp_flavor != "alpine" ]] && print_syntax_error "$@"

					check_dependencies "$@"
					remove_chroot "$@"
				;;
				-V | --version)
					print_version
				;;
				-v | --void)
					[[ $# -ne 1 ]] && print_syntax_error "$@"

					terp_flavor="void"
					check_dependencies "$@"
					unmount_chroot "$@"
				;;
				-*)
					[[ -z ${primary_options#*\-} || -z ${primary_options/\-\-*} ]] && {
						print_error "Unrecognized option '${primary_options}'"
						print_notification
					}

					print_error "Invalid option -- '${primary_options#*\-}'"
					print_notification
				;;
				*)
					print_error "Unrecognized option '${primary_options}'"
					print_notification
				;;
			esac
		done
	}

	trap 'run_on_exit' 1 2 3 15
	print_no_argument "$@"
	check_input_option "$@"
	check_dependencies "$@"
	exit
}

#--------------------------------------------------------------
# Platform: Device Agnostic
# Dependencies: bash
#--------------------------------------------------------------
tfetch() {
	print_help() {
echo -e "\033[1;97mNAME\033[00m
	$SCRIPT_NAME - system resource information tool.

\033[1;97mSYNOPSIS\033[00m
	$SCRIPT_NAME [OPTION]

\033[1;97mDESCRIPTION\033[00m
	\033[1;97m$SCRIPT_NAME\033[00m displays system hardware information.

	\033[1;97m-h, --help\033[00m
		display this help message and exit.

	\033[1;97m-V, --version\033[00m
		output version information and exit.

\033[1;97mAUTHOR\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.
	Written by Kolade Ayomide Olanrewaju.

\033[1;97mREPORTING BUGS\033[00m
	Create a new issue at <https://github.com/teth3r/tether/>.

\033[1;97mCOPYRIGHT\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.

tether $SCRIPT_VERSION"
exit 0
	}

	check_dependencies() {
		# Source Linux OS details
		[[ ! -d /system/app/ || ! -f /system/build.prop ]] && {
			source "/etc/os-release" 2>/dev/null ||
			print_file_read_error "/etc/os-release"
		}

		# Source files once to reduce runtime
		cpu_file="$(< /proc/cpuinfo)"
		mem_file="$(< /proc/meminfo)"

		# Declare colors
		color_blue="\033[1;34m"
		color_magenta="\033[1;35m"
		color_cyan="\033[1;36m"
		color_white="\033[1;97m"
		no_color="\033[00m"

		# Fixes empty $USER in non-root termux
		[[ -z $USER ]] && {
			: '\u'
			USER="${_@P}"
		}

		# Handles empty $HOSTNAME
		[[ -z $HOSTNAME ]] && {
			: '\h'
			HOSTNAME="${_@P}"
		}
	}

	get_hostname() {
		[[ $USER == "shell" || $EUID -eq 2000 ]] && {
			color_blue=$color_cyan
			printf '%b %s@%s %b\n' "${color_blue}" "$USER" "$HOSTNAME" "${no_color}"
			return 0
		}

		[[ $USER == "root" || $EUID -eq 0 ]] && {
			color_blue=$color_magenta
			printf '%b %s@%s %b\n' "${color_blue}" "$USER" "$HOSTNAME" "${no_color}"
			return 0
		}

		[[ $EUID -eq 1000 ]] || [[ $USER != root && $USER != shell ]] && {
			printf '%b %s@%s %b\n' "${color_blue}" "$USER" "$HOSTNAME" "${no_color}"
			return 0
		}
	}

	get_device_name() {
		[[ -f /sys/firmware/devicetree/base/model ]] && {
			IFS= read -r -d '' device_name < /sys/firmware/devicetree/base/model
		}

		[[ -f /proc/device-tree/model ]] && {
			IFS= read -r -d '' device_name < /proc/device-tree/model
		}

		[[ -d /sys/devices/virtual/dmi/id ]] && {
			device_name="$(< /sys/devices/virtual/dmi/id/board_vendor)"
			device_name="${device_name} $(< /sys/devices/virtual/dmi/id/product_name)"
		}

		printf '%s\n\n' "$device_name"
	}

	get_os_name() {
		# Handles Android
		[[ -d /system/app/ ]] && {
			printf 'Android %s %s\n' "$ANDROID_VERSION" "$HOSTTYPE"
		}

		# Handles non-Android OS
		[[ ! -d /system/app/ ]] && {
			printf '%s %s\n' "$PRETTY_NAME" "$HOSTTYPE"
		}
	}

	get_kernel() {
		kernel_version="$(< /proc/version)"
		kernel_version="${kernel_version/\(*}"
		kernel_version="${kernel_version/version\ }"

		printf '%s\n' "$kernel_version"
	}

	get_init() {
		# Handles proper systems
		[[ -d /proc/1 ]] && {
			init_program="$(< /proc/1/status)"
			init_program="${init_program/*Name:}"
			init_program="${init_program/Umask:*}"
			init_program="${init_program//[[:space:]]}"
			printf '%s\n' "$init_program"
		}

		# Handles android chroot
		[[ -z $init_program && $PRETTY_NAME == *Linux* && -d /sys/class/power_supply/battery ]] && {
			printf '%s\n' "init"
		}
	}

	get_pkgs() {
		# Handles Linux with xbps
		[[ $(type -p xbps-install) ]] && [[ ! -d /system/app/ ]] && {
			package_count="0"
			for package_list in /var/db/xbps/.*; do
				package_count="$((package_count + 1))"
			done
			printf '%s xbps\n' "${package_count//[[:space:]]}"
		}

		# Handles Linux with apt
		[[ $(type -p apt) || $(type -p apt-get) ]] && [[ ! -d /system/app/ ]] && {
			package_count="0"
			for package_list in /var/lib/dpkg/info/*.md5sums; do
				package_count="$((package_count + 1))"
			done
			printf '%s apt\n' "${package_count//[[:space:]]}"
		}

		# Handles Linux with apk
		[[ $(type -p apk) ]] && [[ ! -d /system/app/ ]] && {
			package_count="0"
			for package_list in $(< /etc/apk/world); do
				package_count="$((package_count + 1))"
			done
			printf '%s apk\n' "${package_count//[[:space:]]}"
		}

		# Handles Android
		[[ -d /config/sdcardfs && -d /system/app ]] && {
			package_count="0"
			for package_list in /config/sdcardfs/*/; do
				[[ $package_list != /config/sdcardfs/extensions/ ]] && {
					package_count="$((package_count + 1))"
				}
			done
			printf '%s apks\n' "${package_count//[[:space:]]}"
		}
	}

	get_shell() {
		[[ -n $BASH ]] && printf '%s %s\n' "${BASH##*/}" "${BASH_VERSION/-*}"
		[[ -z $BASH ]] && printf '%s\n' "${SHELL##*/}"
	}

	get_desktop() {
		desktop_environment="${XDG_CURRENT_DESKTOP:=$DESKTOP_SESSION}"

		[[ -n ${desktop_environment//[[:space:]]} && -z $XDG_SESSION_TYPE ]] && {
			printf '%s\n' "${desktop_environment}"
		}

		[[ -n ${desktop_environment//[[:space:]]} && -n $XDG_SESSION_TYPE ]] && {
			printf '%s (%s)\n' "${desktop_environment}" "${XDG_SESSION_TYPE}"
		}
	}

	get_cpu() {
		# Handles Android devices
		[[ -d /sys/class/power_supply/battery ]] && {
			cpu_name="${cpu_file/*Hardware*:\ }"
		}

		# Handles Intel CPUs
		# Check if desktop is linux and CPU is not AMD
		[[ ! -d /sys/class/power_supply/battery && $cpu_file != *AuthenticAMD* ]] ||
		# Check if device is not Android with Snapdragon CPU
		[[ ! -d /sys/class/kgsl && ! -d /sys/class/power_supply/battery ]] ||
		# Check if device is not Android with Mediatek CPU
		[[ ! -d /proc/gpufreq && ! -d /sys/class/power_supply/battery ]] && {
			cpu_name="$cpu_file"
			cpu_name="${cpu_name/@*}"
			cpu_name="${cpu_name/*model name*:\ }"
		}

		# Handles AMD CPUs
		[[ $cpu_file == *AuthenticAMD* ]] && {
			cpu_name="${cpu_file/stepping*:*}"
			cpu_name="${cpu_name/*model name*:\ }"
			cpu_name="${cpu_name%[[:space:]]}"
		}

		# Get CPU clockspeed
		cpu_clk="$(( $(< /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq) / 1000 ))"

		# Handles Android with Snapdragon CPUs  -- prime core is the last core
		[[ -d /sys/class/kgsl/kgsl-3d0 ]] && {
			cpu_clk="$(( $(< /sys/devices/system/cpu/cpu$((CPU_CORE_COUNT - 1))/cpufreq/scaling_cur_freq) / 1000 ))"
		}
		printf '%s (%d) @ %dMhz\n' "${cpu_name}" "$CPU_CORE_COUNT" "${cpu_clk}"
	}

	get_cpu_clusters() {
		core_domain=1

		for cpu_cluster in /sys/devices/system/cpu/cpufreq/policy*; do
			# Create Array containing current clockspeed (in Mhz) and member cores of each CPU cluster
			cluster_clk[core_domain]="$(( $(< "$cpu_cluster"/scaling_cur_freq) / 1000 )), $(< "$cpu_cluster"/affected_cpus)"

			# Count the number of available core domains / CPU cluster
			core_domain=$((core_domain + 1))
		done

		for ((cpu_cluster=1; cpu_cluster < core_domain; cpu_cluster++)); do
			# Cpu group lower limit i.e 0 in 0 1 2 3
			cpu_low="${cluster_clk[$cpu_cluster]/*,\ }"
			cpu_low="${cpu_low/\ *}"

			# Cpu group upper limit i.e 3 in 0 1 2 3
			cpu_high="${cluster_clk[$cpu_cluster]/*\ }"

			# Create array for cpu clusters i.e 0-4 @ 2400Mhz
			cpu_clk[cpu_cluster]="$cpu_low-$cpu_high @ ${cluster_clk[$cpu_cluster]/,*}Mhz,"

			# Show only 0 in case cpu group contains only one core
			[[ $cpu_low == "$cpu_high" ]] && {
				cpu_clk[cpu_cluster]="$cpu_high @ ${cluster_clk[$cpu_cluster]/,*}Mhz,"
			}
		done

		# Clean up output
		cpu_total="${cpu_clk[*]}"
		printf '%s\n' "${cpu_total%,}"
	}

	get_gpu() {
		# Handles Mediatek GPUs
		[[ -d /proc/gpufreq ]] && {
			gpu_name="${cpu_file/gpu_name/*Hardware*:\ }"
			gpu_clk="$(( $(< /proc/gpufreq/cur_freq) / 1000 ))"
			printf '%s @ %dMhz\n' "${gpu_name}" "${gpu_clk}"
		}

		# Handles Snapdragron GPUs
		[[ -d /sys/class/kgsl/kgsl-3d0 ]] && {
			gpu_name="$(< /sys/class/kgsl/kgsl-3d0/gpu_model)"
			gpu_clk="$(( $(< /sys/class/kgsl/kgsl-3d0/gpuclk) / 1000000 ))"
			printf '%s @ %dMhz\n' "${gpu_name}" "${gpu_clk}"
		}
	}

	get_battery_stats() {
		[[ -d /sys/class/power_supply/BAT0 ]] && {
			battery_status="$(< /sys/class/power_supply/BAT0/status)"
			battery_capacity="$(< /sys/class/power_supply/BAT0/capacity)"

			[[ -f /sys/class/power_supply/BAT0/charge_full_design ]] && {
				battery_full="$(< /sys/class/power_supply/BAT0/charge_full)"
				battery_full_design="$(< /sys/class/power_supply/BAT0/charge_full_design)"
				battery_health="$((( battery_full * 100 ) / battery_full_design ))"
				battery_health_decimal="$((( battery_full * 10000 ) / battery_full_design % 100 ))"
				printf '%s, %d%% - (%d.%d%% Health)\n' "${battery_status}" "${battery_capacity}" "${battery_health}" "${battery_health_decimal}"
				return
			}
		}

		[[ -d /sys/class/power_supply/battery ]] && {
			battery_status="$(< /sys/class/power_supply/battery/status)"
			battery_capacity="$(< /sys/class/power_supply/battery/capacity)"

			[[ -f /sys/class/power_supply/battery/charge_full_design ]] && {
				battery_full="$(< /sys/class/power_supply/battery/charge_full)"
				battery_full_design="$(< /sys/class/power_supply/battery/charge_full_design)"
				battery_health="$((( battery_full * 100 ) / battery_full_design ))"
				battery_health_decimal="$((( battery_full * 10000 ) / battery_full_design % 100 ))"
				printf '%s, %d%% - (%d.%d%% Health)\n' "${battery_status}" "${battery_capacity}" "${battery_health}" "${battery_health_decimal}"
				return
			}
		}

		printf '%s, %d%%\n' "${battery_status}" "${battery_capacity}"
	}

	get_cpu_temp() {
		[[ -d /sys/class/power_supply/battery ]] && {
			cpu_temp="$(< /sys/class/thermal/thermal_zone3/temp)"
			cpu_temp_decimal="$((cpu_temp % 1000))"
			cpu_temp_decimal="$((cpu_temp_decimal / 100))"
			cpu_temp="$((cpu_temp / 1000))"
		}

		[[ -d /sys/class/power_supply/BAT0 ]] || [[ ! -d /sys/class/kgsl && ! -d /sys/class/power_supply/battery ]] || [[ ! -d /proc/gpufreq && ! -d /sys/class/power_supply/battery ]] && {
			cpu_temp="$(< /sys/class/thermal/thermal_zone0/temp)"
			cpu_temp_decimal="$((cpu_temp % 1000))"
			cpu_temp_decimal="$((cpu_temp_decimal / 100))"
			cpu_temp="$((cpu_temp / 1000))"
		}

		usage_visualizer="$cpu_temp"
		printf '%s %d.%d°C\n' "$(print_usage_bar)" "${cpu_temp}" "${cpu_temp_decimal}"
	}

	get_gpu_temp() {
		# Handles Snapdragron GPUs
		[[ -f /sys/class/kgsl/kgsl-3d0/temp ]] && {
			gpu_temp="$(< /sys/class/kgsl/kgsl-3d0/temp)"
			gpu_temp_decimal="$((gpu_temp % 1000))"
			gpu_temp_decimal="$((gpu_temp_decimal / 100))"
			gpu_temp="$((gpu_temp / 1000))"
			usage_visualizer="$gpu_temp"
			printf '%s %d.%d°C\n' "$(print_usage_bar)" "${gpu_temp}" "${gpu_temp_decimal}"
		}
	}

	get_battery_temp() {
		battery_temp="$(< /sys/class/power_supply/battery/temp)"
		battery_temp_decimal="$((battery_temp % 10))"
		battery_temp="$((battery_temp / 10))"

		usage_visualizer="$battery_temp"
		printf '%s %d.%d°C\n' "$(print_usage_bar)" "${battery_temp}" "${battery_temp_decimal}"
	}

	get_mem() {
		# Get MemTotal
		total_mem="${mem_file/*MemTotal: }"
		total_mem="${total_mem/ kB*}"

		# Get UsedMem
		# UsedMem = MemTotal - MemAvailable
		used_mem="${mem_file/*MemAvailable: }"
		used_mem="${used_mem/ kB*}"
		used_mem="$(( (total_mem - used_mem) / 1024 ))"

		# Convert to MiB
		total_mem="$((total_mem / 1024))"

		# Convert to percentage for print_usage_bar
		usage_visualizer="$((( used_mem * 100 ) / total_mem ))"

		printf '%s %d / %d MiB (%d%%)\n' "$(print_usage_bar)" "$used_mem" "$total_mem" "${usage_visualizer}"
	}

	get_swap() {
		# Get SwapTotal
		total_swap="${mem_file/*SwapTotal: }"
		total_swap="${total_swap/ kB*}"

		# Get SwapFree
		free_swap="${mem_file/*SwapFree: }"
		free_swap="${free_swap/ kB*}"

		# Get UsedSwap
		# UsedSwap = SwapTotal - SwapFree
		used_swap="$(((total_swap - free_swap) / 1024 ))"

		total_swap="$((total_swap / 1024))"

		[[ $total_swap -gt 0 ]] && {
			usage_visualizer="$(((used_swap * 100) / total_swap ))"
			printf '%s %d / %d MiB (%d%%)\n' "$(print_usage_bar)" "$used_swap" "$total_swap" "${usage_visualizer}"
		}

		[[ $total_swap -le 0 ]] && {
			printf '%s %d / %d MiB\n' "$(print_usage_bar)" "$used_swap" "$total_swap"
		}
	}

	get_uptime() {
		system_uptime="$(< /proc/uptime)"
		system_uptime="${system_uptime/.*}"

		in_days="$((system_uptime / 60 / 60 / 24)) days"

		in_hours="$((system_uptime / 60 / 60 % 24)) hours"

		in_minutes="$((system_uptime / 60 % 60)) minutes"

		in_seconds="$((system_uptime % 60)) seconds"

		# Make output suffix singular if value is 1
		[[ ${in_days/ *} -eq 1 ]] && in_days="${in_days/s}"
		[[ ${in_hours/ *} -eq 1 ]] && in_hours="${in_hours/s}"
		[[ ${in_minutes/ *} -eq 1 ]] && in_minutes="${in_minutes/s}"
		[[ ${in_seconds/ *} -eq 1 ]] && in_seconds="${in_seconds%s}"

		printf '%s, %s, %s, %s\n' "${in_days}" "${in_hours}" "${in_minutes}" "${in_seconds}"
	}

	tfetch_config() {
		printf '\n'
		get_hostname "$@"
		printf '%s\n' " -----------------"
		# Show only if device name is available
		[[ -d /sys/devices/virtual/dmi/id || -f /sys/firmware/devicetree/base/model || -f /proc/device-tree/model ]] && {
			printf '%b Device:   %b%s %b\n' "${color_blue}" "${color_white}" "$(get_device_name)" "${no_color}"
		}

		printf '%b OS:       %b%s %b\n' "${color_blue}" "${color_white}" "$(get_os_name)" "${no_color}"
		printf '%b Kernel:   %b%s %b\n' "${color_blue}" "${color_white}" "$(get_kernel)" "${no_color}"
		printf '%b Init:     %b%s %b\n' "${color_blue}" "${color_white}" "$(get_init)" "${no_color}"
		printf '%b Packages: %b%s %b\n' "${color_blue}" "${color_white}" "$(get_pkgs)" "${no_color}"
		printf '%b Shell:    %b%s %b\n' "${color_blue}" "${color_white}" "$(get_shell)" "${no_color}"

		# Show on non-root Linux desktop
		[[ -n ${XDG_CURRENT_DESKTOP:=$DESKTOP_SESSION} ]] && {
			printf '%b Desktop:  %b%s %b\n' "${color_blue}" "${color_white}" "$(get_desktop)" "${no_color}"
		}

		# Show only if CPU files are present, i.e will be absent in a VM
		[[ -f /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq ]] && {
			printf '%b CPU:      %b%s %b\n' "${color_blue}" "${color_white}" "$(get_cpu)" "${no_color}"
		}

		# Show only on Android or desktops with $CPU_CORE_COUNT <= 8
		[[ -d /sys/class/power_supply/battery || $CPU_CORE_COUNT -le 8 ]] && {
			printf '%b CPU_CLK:  %b%s %b\n' "${color_blue}" "${color_white}" "$(get_cpu_clusters)" "${no_color}"
		}

		# Show only on Android with Mediatek or Snapdragon SOC
		[[ -f /proc/gpufreq/cur_freq || -f /sys/class/kgsl/kgsl-3d0/gpuclk ]] && {
			printf '%b GPU:      %b%s %b\n' "${color_blue}" "${color_white}" "$(get_gpu)" "${no_color}"
		}

		# Show only if battery is available
		[[ -d /sys/class/power_supply/BAT0 || -d /sys/class/power_supply/battery ]] && {
			printf '%b Battery:  %b%s %b\n' "${color_blue}" "${color_white}" "$(get_battery_stats)" "${no_color}"
		}

		# Show only if CPU files are present, i.e will be absent in a VM
		[[ -f /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq ]] && {
			printf '%b CPU Temp: %b%b %b\n' "${color_blue}" "${color_white}" "$(get_cpu_temp)" "${no_color}"
		}

		# Show only on Android with Snapdragon SOC
		[[ -f /sys/class/kgsl/kgsl-3d0/temp ]] && {
			printf '%b GPU Temp: %b%b %b\n' "${color_blue}" "${color_white}" "$(get_gpu_temp)" "${no_color}"
		}

		# Show only on Android
		[[ -f /sys/class/power_supply/battery/temp ]] && {
			printf '%b BAT Temp: %b%b %b\n' "${color_blue}" "${color_white}" "$(get_battery_temp)" "${no_color}"
		}

		printf '%b RAM:      %b%b %b\n' "${color_blue}" "${color_white}" "$(get_mem)" "${no_color}"
		printf '%b Swap:     %b%b %b\n' "${color_blue}" "${color_white}" "$(get_swap)" "${no_color}"
		printf '%b Uptime:   %b%s %b\n\n' "${color_blue}" "${color_white}" "$(get_uptime)" "${no_color}"
		exit 0
	}
	tfetch_config_noroot() {
		printf '\n'
		get_hostname "$@"
		printf '%s\n' " -----------------"

		[[ -f /product/etc/build.prop ]] && {
			printf '%b OS:       %b%s %b\n' "${color_blue}" "${color_white}" "$(get_os_name)" "${no_color}"
		}

		printf '%b Shell:    %b%s %b\n' "${color_blue}" "${color_white}" "$(get_shell)" "${no_color}"

		# Show only if CPU files are present, i.e will be absent in a VM
		[[ -f /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq ]] && {
			printf '%b CPU:      %b%s %b\n' "${color_blue}" "${color_white}" "$(get_cpu)" "${no_color}"
		}

		# Show only on Android or desktops with $CPU_CORE_COUNT <= 8
		[[ -d /sys/class/power_supply/battery || $CPU_CORE_COUNT -le 8 ]] && {
			printf '%b CPU_CLK:  %b%s %b\n' "${color_blue}" "${color_white}" "$(get_cpu_clusters)" "${no_color}"
		}

		# Show only if CPU files are present, i.e will be absent in a VM
		[[ -f /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq ]] && {
			printf '%b CPU Temp: %b%b %b\n' "${color_blue}" "${color_white}" "$(get_cpu_temp)" "${no_color}"
		}

		printf '%b RAM:      %b%b %b\n' "${color_blue}" "${color_white}" "$(get_mem)" "${no_color}"
		printf '%b Swap:     %b%b %b\n\n' "${color_blue}" "${color_white}" "$(get_swap)" "${no_color}"
		exit 0
	}

	trap 'run_on_exit' 1 2 3 15
	input_option_type_two "$@"
	check_dependencies "$@"

	# Check if running as non-privileged user on Android
	[[ $OSTYPE == *android* ]] && [[ $USER != "root" || $EUID -ne 0 ]] && [[ -n $EUID ]] && {
		tfetch_config_noroot "$@"
	}

	tfetch_config "$@"
	exit
}

#--------------------------------------------------------------
# Platform: Device Agnostic
# Dependencies: 7zip, touch, rm
#--------------------------------------------------------------
touchzip() {
	print_help() {
echo -e "\033[1;97mNAME\033[00m
	$SCRIPT_NAME - create 7z archives.

\033[1;97mSYNOPSIS\033[00m
	$SCRIPT_NAME [OPTION] [FILENAME] [FILE(s)...]

\033[1;97mDESCRIPTION\033[00m
	\033[1;97m$SCRIPT_NAME\033[00m creates an (un)encrypted [FILENAME].7z archive file of the
	specified [FILE(s)...].

	\033[1;97m-en, --encrypt\033[00m [FILENAME] [FILE(s)...]
		create an encrypted [FILENAME].7z archive of [FILE(s)...].

	\033[1;97m-h,  --help\033[00m
		display this help message and exit.

	\033[1;97m-un, --unencrypt\033[00m [FILENAME] [FILE(s)...]
		create an unencrypted [FILENAME].7z archive of [FILE(s)...].

	\033[1;97m-V,  --version\033[00m
		output version information and exit.

\033[1;97mAUTHOR\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.
	Written by Kolade Ayomide Olanrewaju.

\033[1;97mREPORTING BUGS\033[00m
	Create a new issue at <https://github.com/teth3r/tether/>.

\033[1;97mCOPYRIGHT\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.

tether $SCRIPT_VERSION"
exit 0
	}

	check_dependencies() {
		# Prevent bad system call error as non-root user
		[[ -d "/system/app/" && $EUID -gt 0 ]] && print_not_root_user

		archive_name="$2"
		archive_name="${archive_name%.*}"

		# Check for required dependencies
		for mis_dep in touch rm 7z; do
			[[ ! $(type -p "$mis_dep") ]] && {
				print_missing_dependencies "$mis_dep"
			}
		done

		# Check destination directory for write permissions
		touch "${archive_name}_${SCRIPT_NAME}" 2>/dev/null || print_file_write_error "${archive_name}.7z"
		rm "${archive_name}_${SCRIPT_NAME}"

		# Check if specified files exist
		for check_existing in "${@:3}"; do
			[[ ! -e $check_existing ]] && {
				print_error "Cannot stat '$check_existing': No such file or directory"
				exit 1
			}
		done

		# Check if filename already exists
		[[ -e ${archive_name}.7z ]] && {
			print_error "Cannot create archive '${archive_name}.7z': File exists"
			exit 1
		}
	}

	failed_to_create() {
		print_error "Something went wrong"
		print_aligned "Failed to create 7z archive '${archive_name}.7z'"
		rm "${archive_name}.7z" 2>/dev/null
		unset file_password file_password2
		exit 1
	}

	encrypted_archive() {
		print_warning "Creating an encrypted 7z archive"
		printf '\n'

		# Handles password creation
		create_password "$@"

		unset exit_status
		7z a -snl -snh -p"$file_password" -t7z -mx1 -mmt"$CPU_CORE_COUNT" -mhe=on "${archive_name}.7z" "${@:3}" &>/dev/null && exit_status=0

		[[ -n $exit_status && $exit_status -eq 0 ]] && {
			print_success "Created encrypted 7z archive '${archive_name}.7z'"
			unset file_password file_password2
			exit 0
		}

		failed_to_create "$@"
	}

	unencrypted_archive() {
		print_warning "Creating an unencrypted 7z archive"
		printf '\n'

		unset exit_status
		7z a -snl -snh -t7z -mx1 -mmt"$CPU_CORE_COUNT" -y "${archive_name}.7z" "${@:3}" &>/dev/null && exit_status=0
		[[ -n $exit_status && $exit_status -eq 0 ]] && {
			print_success "Created unencrypted 7z archive '${archive_name}.7z'"
			exit 0
		}

		failed_to_create "$@"
	}

	check_input_option() {
		for primary_options in "${@:1}"; do
			case "$primary_options" in
				-h | --help)
					print_help
				;;
				-en | --encrypt)
					[[ $# -lt 3 ]] && {
						print_syntax_error
					}
					encrypted_archive "$@"
				;;
				-un | --unencrypt)
					[[ $# -lt 3 ]] && {
						print_syntax_error
					}
					unencrypted_archive "$@"
				;;
				-V | --version)
					print_version
				;;
				-*)
					[[ -z ${primary_options#*\-} || -z ${primary_options/\-\-*} ]] && {
						print_error "Unrecognized option '${primary_options}'"
						print_notification
					}

					print_error "Invalid option -- '${primary_options#*\-}'"
					print_notification
				;;
				*)
					for secondary_options in "${@:2}"; do
						case "$secondary_options" in
							-h | --help)
								print_help
							;;
						esac
					done
					print_syntax_error
				;;
			esac
		done
	}

	trap 'run_on_exit' 1 2 3 15
	print_no_argument "$@"
	check_dependencies "$@"
	check_input_option "$@"
	exit
}

#--------------------------------------------------------------
# Platform: Android
# Dependencies: 7zip, pm, mkdir
#--------------------------------------------------------------
whatsapp-backup() {
	print_help() {
echo -e "\033[1;97mNAME\033[00m
	$SCRIPT_NAME - create and restore whatsapp backups.

\033[1;97mSYNOPSIS\033[00m
	$SCRIPT_NAME [OPTION]

\033[1;97mDESCRIPTION\033[00m
	\033[1;97m$SCRIPT_NAME\033[00m creates or restores (un)encrypted backups of
	Whatsapp. It saves and restores the backups from external storage
	and will only fallback to using Android's internal storage if no
	external storage device exists.

	\033[1;97m-en, --encrypt\033[00m
		create an encrypted backup of whatsapp.

	\033[1;97m-h,  --help\033[00m
		display this help message and exit.

	\033[1;97m-l,  --list\033[00m
		list available backup(s).

	\033[1;97m-un, --unencrypt\033[00m
		create an unencrypted backup of whatsapp.

	\033[1;97m-r,  --restore\033[00m
		restore whatsapp from available backup(s).

	\033[1;97m-V,  --version\033[00m
		output version information and exit.

\033[1;97mAUTHOR\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.
	Written by Kolade Ayomide Olanrewaju.

\033[1;97mREPORTING BUGS\033[00m
	Create a new issue at <https://github.com/teth3r/tether/>.

\033[1;97mCOPYRIGHT\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.

tether $SCRIPT_VERSION"
exit 0
	}

	check_dependencies() {
		# Only run on Android
		[[ ! -d /system/app/ || ! -f /system/build.prop ]] && {
			print_os_error
		}

		# Check for required dependencies
		for mis_dep in 7z pm mkdir; do
			[[ ! $(type -p "$mis_dep") ]] && {
				print_missing_dependencies "$mis_dep"
			}
		done

		# Only run as root user
		print_not_root_user

		# SAF was rolled out in Android 11
		[[ $ANDROID_VERSION -lt 11 ]] && print_os_error

		# Declare whatsapp versions
		whatsapp_classic="$PHONE_STORAGE/Android/media/com.whatsapp"
		whatsapp_business="$PHONE_STORAGE/Android/media/com.whatsapp.w4b"

		# Reset whatsapp directory
		unset whatsapp_dir

		# Handles only whatsapp installed
		[[ -d $whatsapp_classic && ! -d $whatsapp_business ]] && {
			whatsapp_dir="$whatsapp_classic"
		}

		# Handles only whatsapp business installed
		[[ -d $whatsapp_business && ! -d $whatsapp_classic ]] && {
			whatsapp_dir="$whatsapp_business"
		}

		# Priotize whatsapp business if both whatsapp versions are installed
		[[ -d $whatsapp_business && -d $whatsapp_classic ]] && {
			whatsapp_dir="$whatsapp_business"
		}

		# Handles no whatsapp install
		[[ ! $(pm list packages "com.whatsapp" 2>/dev/null) ]] && {
			print_error "Whatsapp is not installed"
			print_notification
			exit 1
		}

		# Handles missing $whatsapp_dir
		[[ $(pm list packages "com.whatsapp" 2>/dev/null) && ! -d $whatsapp_dir ]] && {
			print_error "Cannot stat '${whatsapp_dir:=com.whatsapp}': No such file or directory"
			print_aligned "Try running 'Whatsapp' at least once"
			exit 1
		}

		# Set whatsapp backup directory
		whatsapp_backup_dir="$PHONE_STORAGE/Misc/whatsapp-backup"

		# Use external storage if available
		[[ -d "$EXTERNAL_STORAGE" ]] && {
			whatsapp_backup_dir="$EXTERNAL_STORAGE/Misc/whatsapp-backup"
		}

		# Set current current directory
		current_dir="$PWD"

		# Get date and time in YYYY.MM.DD.HH.MM format
		current_date="$(printf '%(%Y.%m.%d.%H%M)T\n')"
	}

	failed_to_create() {
		print_error "Something went wrong"
		print_aligned "Failed to create 'whatsapp-backup.${current_date}.7z'"
		rm -rf "$whatsapp_backup_dir/whatsapp-backup.${current_date}.7z" 2>/dev/null

		# CD back to original directory
		cd "$current_dir" 2>/dev/null || print_dir_change_error "${current_dir}"
		exit 1
	}

	failed_to_extract() {
		printf '\n'
		print_error "Failed to extract '${backup_list[$backup_option]}'"
		exit 1
	}

	encrypted_backup_whatsapp() {
		print_warning "Creating encrypted backup 'whatsapp-backup.${current_date}.7z'"
		printf '\n'

		# Handles password creation
		create_password "$@"

		cd "$whatsapp_dir" 2>/dev/null || print_dir_change_error "${whatsapp_dir}"
		mkdir -p "$whatsapp_backup_dir" || print_write_error "$whatsapp_backup_dir"

		# Compress and encrypt $whatsapp-dir contents
		7z a -snl -snh -p"$file_password" -t7z -mx1 -mmt"$CPU_CORE_COUNT" -mhe=on "$whatsapp_backup_dir/whatsapp-backup.${current_date}.7z" "*" &>/dev/null ||
		failed_to_create "$@"
		unset file_password file_password2
		print_success "Finished encrypting 'whatsapp-backup.${current_date}.7z'"
		print_aligned "Check '$whatsapp_backup_dir'"

		# CD back to original directory
		cd "$current_dir" 2>/dev/null || print_dir_change_error "${current_dir}"
		exit 0
	}

	unencrypted_backup_whatsapp() {
		print_warning "Creating unencrypted backup 'whatsapp-backup.${current_date}.7z'"
		printf '\n'

		cd "$whatsapp_dir" 2>/dev/null || print_dir_change_error "${whatsapp_dir}"
		mkdir -p "$whatsapp_backup_dir" || print_write_error "$whatsapp_backup_dir"

		# Compress $whatsapp-dir contents
		7z a -snl -snh -t7z -mx1 -mmt"$CPU_CORE_COUNT" -y "$whatsapp_backup_dir/whatsapp-backup.${current_date}.7z" "*" &>/dev/null ||
		failed_to_create "$@"
		print_success "Finished creating 'whatsapp-backup.${current_date}.7z'"
		print_aligned "Check '$whatsapp_backup_dir'"

		# CD back to original directory
		cd "$current_dir" 2>/dev/null || print_dir_change_error "${current_dir}"
		exit 0
	}

	restore_whatsapp() {
		# Set variables for available backups
		array_counter=1

		for avail_backup in "$whatsapp_backup_dir"/*; do
			[[ -e $avail_backup ]] && {
				backup_list[array_counter]="${avail_backup//*\/}"
				array_counter=$((array_counter + 1))
			}
		done

		# Handles no available backups
		[[ $array_counter -eq 1 ]] && {
			print_error "No available backups to restore from"
			exit 1
		}

		# List available backups
		print_banner
		print_warning "Restoring whatsapp"
		printf '\n'
		for ((array_checker=1; array_checker < array_counter; array_checker++)); do
			printf '%s.%s\n' "${array_checker}" "${backup_list[$array_checker]}"
		done
		printf '\n'
		read -rep "Select preferred backup: " backup_option
		case "$backup_option" in
			-*)
				printf '\n'
				[[ -z ${backup_option#*\-} ]] && {
					print_error "Unrecognized option '${backup_option}'" &&
					exit 1
				}

				print_error "Invalid option -- '${backup_option#*\-}'" &&
				exit 1
			;;
			*)
				printf '\n'
				[[ $(( backup_option / 1 )) -gt 0 && $backup_option -lt $array_counter ]] && {
					print_warning "Restoring whatsapp using '${backup_list[$backup_option]}'"
					mkdir -p "$whatsapp_dir" || print_write_error "$whatsapp_dir"

					# Extract selected backup file
					7z x "${whatsapp_backup_dir}/${backup_list[$backup_option]}" -mmt"$CPU_CORE_COUNT" -y -o"$whatsapp_dir" 2>/dev/null || failed_to_extract "$@"
					printf '\n'
					print_success "Finished restoring '${backup_list[$backup_option]}'"
					exit 0
				}

				print_error "Unrecognized option '${backup_option}'" &&
				exit 1
			;;
		esac
	}

	check_input_option() {
		for primary_options in "${@:1}"; do
			case "$primary_options" in
				-en | --encrypt)
					check_dependencies "$@"

					# Handles if $whatsapp_dir exists and is empty
					[[ $(printf '%s\n' "$whatsapp_dir/"*) == "$whatsapp_dir/*" ]] && {
						print_error "Nothing to backup"
						print_aligned "Try using your whatsapp more"
						exit 1
					}

					encrypted_backup_whatsapp "$@"
				;;
				-h | --help)
					print_help
				;;
				-l | --list)
					check_dependencies "$@"

					# Handles no available whatsapp backup
					[[ $(printf '%s\n' "$whatsapp_backup_dir/"*) == "$whatsapp_backup_dir/*" ]] && {
						print_error "No available backups"
						exit 1
					}

					printf '\033[1;97mAvailable backups:\033[00m\n'

					backup_content="$(printf '%s\n' "$whatsapp_backup_dir/"*)"
					printf '%s\n' "${backup_content//"${whatsapp_backup_dir}/"}"
					exit 0
				;;
				-un | --unencrypt)
					check_dependencies "$@"

					[[ $(printf '%s\n' "$whatsapp_dir/"*) == "$whatsapp_dir/*" ]] && {
						print_error "Nothing to backup"
						print_aligned "Try using your whatsapp more"
						exit 1
					}

					unencrypted_backup_whatsapp "$@"
				;;
				-r | --restore)
					check_dependencies "$@"
					restore_whatsapp "$@"
				;;
				-V | --version)
					print_version
				;;
				-*)
					[[ -z ${primary_options#*\-} || -z ${primary_options/\-\-*} ]] && {
						print_error "Unrecognized option '${primary_options}'"
						print_notification
					}

					print_error "Invalid option -- '${primary_options#*\-}'"
					print_notification
				;;
				*)
					for secondary_options in "${@:2}"; do
						case "$secondary_options" in
							-h | --help)
								print_help
							;;
						esac
					done
					print_syntax_error
				;;
			esac
		done
	}

	trap 'remove_file_on_exit "$whatsapp_backup_dir/whatsapp-backup.${current_date}.7z"' 1 2 3 15
	print_no_argument "$@"
	check_input_option "$@"
	exit
}

#--------------------------------------------------------------
# Platform: Device Agnostic
# Dependencies: bash, ln, grep, mkdir
#--------------------------------------------------------------
tether() {
	# Check for required dependencies
	for mis_dep in ln grep mkdir; do
		[[ ! $(type -p "$mis_dep") ]] && {
			print_missing_dependencies "$mis_dep"
		}
	done

	# Declare installation directory
	folder_name="$2"

	# Get and parse names of all available functions
	applet_name="$(declare -F)"
	applet_name="${applet_name//declare -f /}"

	# Manage declared applets/functions
	func_count=0
	for applet_count in ${applet_name//tether}; do
		[[ $applet_count != *_* ]] && {
			# Create array with declared functions
			applet[func_count]="${applet_count}"
			# Concatenate string with function names
			function_space+="${applet_count}, "
			# Count available functions
			func_count=$(( func_count + 1 ))
		}
	done

	print_help() {
echo -e "\033[1;97mNAME\033[00m
	$SCRIPT_NAME - multicall shell script.

\033[1;97mSYNOPSIS\033[00m
	$SCRIPT_NAME [FUNCTION] [ARGUMENT(s)...]
	$SCRIPT_NAME [OPTION] [FOLDER]

\033[1;97mDESCRIPTION\033[00m
	\033[1;97m$SCRIPT_NAME\033[00m is a multi-call shell script that combines many applets
	into a single executable. Think busybox, toybox or GNU coreutils,
	except as a shell script. Create symbolic links to \033[1;97m$SCRIPT_NAME\033[00m for each
	function and \033[1;97m$SCRIPT_NAME\033[00m will act like whatever it was invoked as.

	\033[1;97m-b, --banner\033[00m
		display program banner and exit.

	\033[1;97m-h, --help\033[00m
		display this help message and exit.

	\033[1;97m-i, --install\033[00m [FOLDER]
		create symbolic links of all the defined functions in the
		specified [FOLDER].

	\033[1;97m-l, --list\033[00m
		list all defined functions.

	\033[1;97m-s, --silent\033[00m [FOLDER]
		create symbolic links of all the defined functions in the
		specified [FOLDER] without displaying any output.

	\033[1;97m-V,   --version\033[00m
		output version information and exit.

\033[1;97mAUTHOR\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.
	Written by Kolade Ayomide Olanrewaju.

\033[1;97mREPORTING BUGS\033[00m
	Create a new issue at <https://github.com/teth3r/tether/>.

\033[1;97mCOPYRIGHT\033[00m
	Copyright (C) 2023, Kolade Ayomide Olanrewaju. License GPLv3+: GNU
	GPL version 3 or later <https://www.gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.

tether $SCRIPT_VERSION"
exit 0
	}

	check_input_option() {
		for primary_options in "${@:1}"; do
			case "$primary_options" in
				-b | --banner)
					print_banner
					exit 0
				;;
				-h | --help)
					print_help
				;;
				-i | --install)
					[[ $# -gt 2 ]] && {
						print_syntax_error
					}

					[[ $# -eq 1 ]] && {
						print_error "Missing destination file operand after '$primary_options'"
						print_notification
					}

					for function_flat in "${applet[@]}"; do
						mkdir -p "$folder_name" 2>/dev/null || print_write_error "$folder_name"
						ln -sf "$SCRIPT_NAME" "$folder_name/$function_flat" 2>/dev/null || print_file_write_error "$function_flat"
						print_success "Created '$function_flat' symlink in '$folder_name'"
					done

					# Handles ./${SCRIPT_NAME}
					[[ -f ${0#\.\/} ]] && {
						cp -f "${0#\.\/}" "$folder_name" 2>/dev/null
					}

					# Handles ./<dirname>/${SCRIPT_NAME}
					[[ -f ${0#\.} ]] && {
						cp -f "${0#\.}" "$folder_name" 2>/dev/null
					}

					exit 0
				;;
				-l | --list)
					printf '\033[1;97mCurrently defined functions (%d):\033[00m\n' "$func_count"
					printf '%s\n' "${function_space%,*}"
					exit 0
				;;
				-s | --silent)
					[[ $# -gt 2 ]] && {
						print_syntax_error
					}

					[[ $# -eq 1 ]] && {
						print_error "Missing destination file operand after '$primary_options'"
						print_notification
					}

					for function_flat in "${applet[@]}"; do
						mkdir -p "$folder_name" 2>/dev/null || print_write_error "$folder_name"
						ln -sf "$SCRIPT_NAME" "$folder_name/$function_flat" 2>/dev/null || print_file_write_error "$function_flat"
					done

					# Handles ./${SCRIPT_NAME}
					[[ -f ${0#\.\/} ]] && {
						cp -f "${0#\.\/}" "$folder_name" 2>/dev/null
					}

					# Handles ./<dirname>/${SCRIPT_NAME}
					[[ -f ${0#\.} ]] && {
						cp -f "${0#\.}" "$folder_name" 2>/dev/null
					}

					exit 0
				;;
				-V | --version)
					print_version
				;;
				-*)
					[[ -z ${primary_options#*\-} || -z ${primary_options/\-\-*} ]] && {
						print_error "Unrecognized option '${primary_options}'"
						print_notification
					}

					print_error "Invalid option -- '${primary_options#*\-}'"
					print_notification
				;;
				*)
					# Handles main script
					# Example: tether mkcp newfolder file
					[[ $(printf '%s\n' "${applet[@]}" | grep -x "$1" 2>/dev/null) ]] && {
						# Makes $SCRIPT_NAME the name of the executed function
						SCRIPT_NAME="${1}"
						"${@:1}"
						exit 0
					}

					# Handles renamed main program
					[[ $SCRIPT_NAME != "tether" ]] && {
						SCRIPT_NAME="tether"
						print_error "$SCRIPT_NAME: '$0' applet not found"
						exit 1
					}

					# Handles specified function not existing
					# Example: tether dssdsdda
					# Makes $SCRIPT_NAME the name of the main script
					SCRIPT_NAME="${0##*/}"
					print_error "$SCRIPT_NAME: '$1' applet not found"
					exit 1
				;;
			esac
		done
	}

	trap 'run_on_exit' 1 2 3 15
	
	# Handles symlinked applets
	# Example: mkcp newfolder file
	[[ $(printf '%s\n' "${applet[@]}" | grep -x "$SCRIPT_NAME" 2>/dev/null) ]] && {
		"$SCRIPT_NAME" "${@:1}" && exit 0
	}

	# Handles symlinked applets that don't exist
	[[ ! $(printf '%s\n' "${applet[@]}" | grep -x "$SCRIPT_NAME" 2>/dev/null) ]] && [[ $SCRIPT_NAME != "tether" ]] && {
		SCRIPT_NAME="tether"
		print_error "$SCRIPT_NAME: '${0##*/}' applet not found"
		exit 1
	}

	# If no input is specified
	print_no_argument "$@"

	# Handles input arguments to the main script
	check_input_option "$@"

	exit
}

tether "$@"
